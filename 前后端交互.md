# 一、服务器的基本概念与初始Ajax

## 1.客户端与服务器

### 1.1 上网的目的

![image-20220520213410373](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520213410373.png)

上网的本质目的: 通过互联网的形式来获取和消费资源

### 1.2 服务器

上网过程中，负责存放和对外提供资源的电脑,叫做服务器。

服务器的本质: 就是一台电脑，只不过，它的性能要比个人电脑高很多

服务器的概念: 在因特网中，负责存放和对外提供资源的电脑

### 1.3 客户端

上网过程中，负责获取和消费资源的电脑，叫做客户端。

![image-20220520214455256](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520214455256.png)

## 2.URL地址

### 2.1 URL地址的概念

URL (全称是UniformResourceLocator)中文叫**统一资源定位符**， 用于标识互联网上每个资源的唯一存放位置。
浏览器只有通过URL地址，才能正确定位资源的存放位置,从而成功访问到对应的资源。
常见的URL举例: .
http://www.baidu.com

### 2.2 URL地址的组成部分

URL地址一般由三部组成:

1. 客户端与服务器之间的**通信协议**
2. 存有该资源的**服务器名称**
3. 资源在服务器上**具体的存放位置**

![image-20220520215035232](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520215035232.png)

## 3.客户端与服务器的通信过程

### 3.1 图解客户端与服务器的通信过程

![image-20220520215559045](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520215559045.png)

**注意：**

1. 客户端与服务器之间的通信过程,分为**请求-处理-响应**三个步骤。
2. 网页中的每一个资源，都是通过**请求-处理-响应**的方式从服务器获取回来的。

### 3.2 基于浏览器的开发者工具分析通信过程

![image-20220520221152186](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520221152186.png)

![image-20220520221221323](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520221221323.png)

1. 打开Chrome浏览器
2. Ctrl+ Shift+I打开Chrome的开发者工具
3. 切换到Network面板
4. 选中Doc页签
5. 刷新页面，分析客户端与服务器的通信过程

## 4.服务器对外提供了哪些资源

### 4.1 网页中常见的资源

![image-20220520221538539](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520221538539.png)

### 4.2 数据也是资源

网页中的数据，也是服务器对外提供的一种资源。例如股票数据、各行业排行榜等。

![image-20220520221803688](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520221803688.png)

### 4.3 数据是网页的灵魂

![image-20220520222239491](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520222239491.png)

- HTML 是网页的骨架
- CSS是网页的颜值
- Javascript是网页的行为
- 数据，则是网页的灵魂

骨架、颜值、行为皆为数据服务
数据，在网页中无处不在

### 4.4 网页中如何请求数据

数据，也是服务器对外提供的一种资源。只要是资源，必然要通过请求-处理-响应的方式进行获取。

![image-20220520223309536](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220520223309536.png)

如果要在网页中请求服务器上的数据资源，则需要用到XMLHttpRequest对象。
XMLHttpRequest (简称xhr)是浏览器提供的js成员，通过它，可以请求服务器上的数据资源。
最简单的用法var xhrObi = new XMLHttpRequest0

### 4.5 资源的请求方式

客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为get和post请求。

- get 请求通常用于获取服务端资源(向服务器要资源)

  ​	例如:根据URL地址，从服务器获取HTML文件、CSs 文件、js文件、 图片文件、数据资源等

- post 请求通常用于向服务器提交数据(往服务器发送资源)

  ​	例如:登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作

## 5.了解Ajax

### 5.1什么是Ajax

Ajax的全称是Asynchronous Javascript And XML (异步JavaScript 和XML)。

通俗的理解:在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax。

### 5.2为什么要学Ajax

之前所学的技术,只能把网页做的更美观漂亮，或添加一些动画效果，但是, Ajax能让我们轻松实现网页与服务器之间的数据交互。

![image-20220521131641730](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521131641730.png)

### 5.3 Ajax的典型应用场景

#### 1.用户名检测: 

注册用户时，通过ajax的形式，动态检测用户名是否被占用

![image-20220521132750420](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521132750420.png)

#### 2.搜索提示:

当输入搜索关键字时,通过ajax的形式,动态加载搜索提示列表

![image-20220521132854136](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521132854136.png)

#### 3.数据分页显示:

当点击顿码值的时候，通过ajax的形式，根据页码值动态刷新表格的数据

![image-20220521133045476](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521133045476.png)

#### 4.数据的增删改查:

数据的添加、删除、修改、查询操作,都需要通过ajax的形式，来实现数据的交互

![image-20220521133516231](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521133516231.png)

## 6.Jquery中的Ajax

### 6.1了解jQuery中的Ajax

浏览器中提供的XMLHttpRequest用法比较复杂，所以jQuery对XMLHttpRequest进行了封装,提供了一系列Ajax相关的函数,极大地降低了Ajax的使用难度。

jQuery中发起Ajax请求最常用的三个方法如下:

- $.get()
- $.post()
- $.ajax()

### 6.2 $.get()函数的语法

jQuery中$.get()函数的功能单一,专门 ]用来发起get求，从而将服务器上的资源请求到客户端来进行使用

$.get()函数的语法如下:

```javascript
$.get(url, [data], [callback])
```

其中，三个参数各自代表的含义如下:

| 参数名   | 参数类型 | 是否必选 | 说明                     |
| -------- | -------- | -------- | ------------------------ |
| url      | string   | 是       | 要请求的资源地址         |
| data     | object   | 否       | 请求资源期间要携带的参数 |
| callback | function | 否       | 请求成功时的回调函数     |

#### 1.$.get()发起不带参数的请求

使用$.get0函数发起不带参数的请求时，直接提供请求的URL地址和请求成功之后的回调函数即可,示例代码如下:

```javascript
$.get('http://www.liulongbin.top:3006/api/getbooks', function(res) {
    consloe.log(res) // 这里的 res 是服务器返回的数据
})
```

![image-20220521142334393](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521142334393.png)

Network面板下的XHR页签 监听和过滤所有的Ajax请求

#### 2.$.get()发起带参数的请求

使用$.get(函数发起带参数的请求时，示例代码如下:

```javascript
$.get('http://www.liulongbin.top:3006/api/getbooks', {id: 1}, function(res) {
	consloe.log(res);
})
```

![image-20220521153133264](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521153133264.png)

### 6.3 $.post()函数的语法

jQuery中$.post)函数的功能单一，专门用来发起post请求,从而向服务器提交数据。

$.post()函数的语法如下:

```javascript
$.post(url, [data], [callback])
```

其中，三个参数各自代表的含义如下;

| 参数名   | 参数类型 | 是否必选 | 说明                     |
| -------- | -------- | -------- | ------------------------ |
| url      | string   | 是       | 提交数据的地址           |
| data     | object   | 否       | 要提交的数据             |
| callback | function | 否       | 数据提交成功时的函调函数 |

#### 1.$.post()向服务器提交数据

使用$post()向服务器提交数据的示例代码如下:

```javascript
 $.post('http://www.liulongbin.top:3006/api/addbook', { bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, function (res) {
                    console.log(res);
                })
```

![image-20220521163057853](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521163057853.png)

### 6.4 $.ajax()函数的语法

相比于$.get() 和$.post()函数，jQuery 中提供的$.ajax()函数，是一个功能比较综合的函数，它允许我们对Ajax请求进行更详细的配置。

$.ajax(函数的基本语法如下:

```javascript
$.ajax({
	type: '', // 请求的方式 例如 GET 或 POST
	url: '', // 请求的 URL 地址
	data: { }, // 这次请求要携带的数据
	success: function() { } // 请求成功之后的回调函数
})
```

#### 1.使用$.ajax()发起GET请求

使用$.ajax0发起GET请求时，只需要将**type属性**的值设置为'**GET**'即可:

```javascript
$.ajax({ 
	type: 'GET', // 请求方式为GRT
	url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的 URL 地址
	data: {id: 1 }, // 这次请求要携带的数据 如果不携带数据 可省略
	success: function(res) { 
		consloe.log(res)
	} // 请求成功之后的回调函数
})
```

#### 2.使用$.ajax() 发起POST请求

使用$.ajax()发起POST请求时，只需要将type属性的值设置为'POST'即可:

```javascript
$.ajax({
	type: 'POST', // 请求方式 也可以小写，
	url: 'http://www.liulongbin.top:3006/api/addbook',
	data: {
		bookname: '史记',
		author: '司马迁',
		publisher: '上海图书出版社'
	}，
	success: function(res) {
		consloe.log(res)
	}
	
})
```

## 7.接口

### 7.1 接口的概念

使用Ajax请求数据时，**被请求的URL地址**，就叫做**数据接口(**简称接口)。同时，每个接口必须有**请求方式**。

例如: .

http://www.liulongbin.top:3006/api/getbooks 获取图书列表的接口(GET请求)

http://www.liulongbin.top:3006/api/addbook 添加图书的接口(POST请求)

### 7.2 分析接口的请求过程

#### 1.通过GET方式请求接口的过程

![image-20220521185207021](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521185207021.png)

#### 2.通过POST方法请求接口的过程

![image-20220521185358947](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521185358947.png)

### 7.3 接口测试工具

#### 1.什么是接口测试工具

为了验证接口能否被正常被访问，我们常常需要使用接口测试工具，来对数据接口进行检测。

**好处**: 接口测试工具能让我们在**不写任何代码**的情况下，对接口进行**调用**和**测试**。

#### 2.下载并安装PostMan

访问PostMan的官方下载网址https://www.getpostman.com/downloads/,下载所需的安装程序后，直接安装即可。

#### 3.了解PostMam界面的组成部分

![image-20220521190235020](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521190235020.png)

### 7.4 使用PostMan测试GET接口

![image-20220521190617081](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521190617081.png)

步骤:

1. 选择请求的方式
2. 填写请求的URL地址
3. 填写请求的参数 (parms里面)
4. 点击Send按钮发起GET请求
5. 查看服务器响应的结果

注意; get参数都要放到parms里面进行填写

### 7.5 使用PostMan测试POST接口

![image-20220521193030260](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521193030260.png)

步骤:
1. 选择请求的方式
2. 填写请求的URL 地址
3. 选择Body面板并勾选数据格式
4. 填写要发送到服务器的数据
5. 击Send按钮发起POST请求
6. 查看服务器响应的结果

### 7.6 接口文档

#### 1.什么是接口文档

接口文档,顾名思义就是**接口的说明文档**，**它是我们调用接口的依据**。好的接口文档包含了对接口URL,参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。

#### 2.接口文档的组成部分

接口文档可以包含很多信息，也可以按需进行精简，不过, 一个合格的接口文档，应该包含以下6项内容,从而为接口的调用提供依据:

1. 接口名称: 用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。
2. 接口URL: 接口的调用地址。
3. 调用方式: 接口的调用方式，如GET或POST.
4. 参数格式: 接口需要传递的参数,每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容。
5. 响应格式: 接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。
6. 返示例(可选) :通过对象的形式，例举服务器返回数据的结构。

#### 3.接口文档示例

请求的根路径

```
http://www.liulongbin.top:3006
```

![image-20220521205609203](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521205609203.png)

![image-20220521205712900](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521205712900.png)

**”+”号代表子属性**

![image-20220521205742924](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521205742924.png)

![image-20220522142621570](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220522142621570.png)

## 8.案例--图书管理

### 8.1 渲染UI结构

![image-20220521205940529](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220521205940529.png)

### 8.2 案例用到的库和插件

用到的Css库bootstrap.css

用到的javascript库jqueryjs

用到的vs code插件Bootstrap 3 Snippets

### 8.3 渲染图书列表(核心代码)

```javascript
function getBookList () {
	// 1.发起ajax请求获取图书列表数据
	$.get ('http:/ /www. liulongbin. top: 3006/api/getbooks'，function (res) {
	// 2.获取列表数据是否成功
	if (res.status !== 200) return alert('获取图书列表失败! ')
	// 3.渲染页面结构
	var rows = []
	$.each (res.data, function(i, item) { // 4.循环拼接字符串
	rows.push( '<tr><td>' + item.id + '</td><td>' + item. bookname +'</td><td>' + item. author + '</td><td>' + item. publisher + '</td><td><a href="javascript:;">删除</a></td></tr>')
})
$(' #bookBody').empty().append(rows.join('')) // 5.渲染表格结构
})
}

```

![image-20220522152633271](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220522152633271.png)

## 9.案列--聊天机器人

### 9.1 演示案列要完成的效果

![image-20220522155229412](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220522155229412.png)

**实现步骤:**

​	①梳理案例的代码结构

​	②将用户输入的内容渲染到聊天窗口

​	③发起请求获取聊天消息

​	④将机器人的聊天内容转为语音

​	⑤通过<audio>播放语音

​	⑥使用回车键发送消息

### 9.2梳理案例的代码结构

​	①梳理页面的UI布局

​	②将业务代码抽离到chat.js中

​	③了解resetui()函数的作用 （重置滚动条的位置)

### 9.3 将用户输入的内容渲染到聊天窗口

```js
//为发送按钮绑定点击事件处理函数
$('#btnSend').on('click', function () {
	var text = $('#ipt').val().trim() // 获取用户输入的内容
	if (text. length <= 0) { //判断用户输入的内容是否为空
		return $('#ipt').val('') 
    }
	//将用户输入的内容显示到聊天窗口中
	$('#talk_list').append('<li class="right_word"><img src="img/ person02.png" /> <span>' + text + '</span></li>')
	resetui() //重置滚动条的位置
	$('#ipt') .va1('') //清空输入框的内容
	// TODO: 发起请求，获取聊天消息
})

```

### 9.4 发起请求获取聊天消息

```js
 function getMsg(text) {
        $.ajax({
            method: 'GET',
            url: 'http://www.liulongbin.top:3006/api/robot',
            data: {
                spoken: text
            },
            success: function (res) {
                console.log(res);
                if (res.message === 'success') {
                    // 接收聊天信息
                    var msg = res.data.info.text;
                    $(".talk_list").append('<li class="left_word"><img src ="./img/roobt.webp" /><span>' + msg + '</span></li>');
                    resetui();
                    // TODO: 发起请求，将机器人的聊天信息转为语音格式
                }
            }

        })
    }
```

### 9.5 将机器人的聊天内容转为语音

```js
function getVoice(text) {
        $.ajax({
            type: 'GET',
            url: 'http://www.liulongbin.top:3006/api/synthesize',
            data: {
                text: text
            },
            success: function (res) {
                // console.log(res);
                if (res.status === 200) {
                    $("#voice").attr("src", res.voiceUrl);
                }
            }

        })
    }

```

#### 9.5.1 [jQuery](https://so.csdn.net/so/search?q=jQuery&spm=1001.2101.3001.7020)中ajax配置项中的使用type与method的区别

本质上两个配置项是没有区别的，区别在于两者出现的时间不同，type对于目前jQuery的版本全部兼容

```js
$.ajax({
        type: 'POST',
        url: 'http://developer.duyiedu.com/edu/testJsonp',//这地址是我用的没有设置跨域的接口
        dataType: 'json',//若出现跨域请求请使用'jsonp'
        data: {
            'userName': userName,
            'password': password
        },
        success: function (data) {
          console.log(data);
        },
        error: function () {
            alert("错误!");
        }
    });
```

这种方式书写，type类型是GET就是GET请求，是POST请求就是POST请求。

#### 9.5.2 在jQuery1.9以后的版本中使用[ajax](https://so.csdn.net/so/search?q=ajax&spm=1001.2101.3001.7020)时，可以使用如下方式

```js
$.ajax({
        method: 'POST',这里不同了
        url: 'http://developer.duyiedu.com/edu/testJsonp',
        data: {
            'userName': userName,
            'password': password
        },
        success: function (data) {
            console.log(data)
        },
        error: function () {
            alert("错误!");
        }
    });

```

实现的功能是一样的，但是如果此时你引入的jQuery的js文件版本太旧，就会出现请求全是以默认方式GET进行的，所以会出现一些无厘头的bug。

### 9.6 通过<audio>播放语音

```html
// 音频播放语音内容
<audio src=" id="voice" autoplay style="display:none;"></ audio>
```

### 9.7 使用回车发送消息

```js
//让文本输入框响应回车事件后，提交消息
$('#ipt').on('keyup', function (e) {
// e. keyCode
可以获取到当前按键的编码
	if (e. keyCode === 13) {
//调用按钮元素的click 函数，可以通过编程的形式触发按钮的点击事件
	$('#btnSend').click()
    }
})
```

# 二、form表单与模板

## 1.form表单的基本使用

### 1.1 什么是表单

表单在网页中主要负责**数据采集功能**。HTML 中的<form>标签,就是用于采集用户输入的信息,并通过<form>标签的提交操作, 把采集到的信息提交到服务器端进行处理。

![image-20220523195918702](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220523195918702.png)

```html
<form>
<input type="text" name="email_ or_ mobile" />
<input type="password" name="password" />
<input type="checkbox" name=" remember_ me" checked />
<button type="submit">提交</button>
</form>
```

### 1.2 表单的组成部分

```html
<form> // 表单标签
   // input 是表单域
	<input type="text" name="email_ or_ mobile" />
	<input type="password" name="password" />
	<input type="checkbox" name=" remember_ me" checked />
	<button type="submit">提交</button> // 表单按钮
</form>
```

表单由三个基本部分组成:

- 表单标签
- 表单域
- 表单按钮

### 1.3 《form》标签的属性

```markdown
<form>标签用来采集数据，<form> 标签的属性则是用来规定如何把采集到的数据发送到服务器。
```

| 属性    | 值                                                           | 描述                                     |
| :------ | :----------------------------------------------------------- | ---------------------------------------- |
| action  | URL地址                                                      | 规定当提交表单时，向何处发送表单数据     |
| method  | get或post                                                    | 规定以何种方式把表单数据提交到action URL |
| enctype | application/x-www-form-urlencoded<br/>multipart/form-data<br/>text/plain | 规定在发送表单数据之前如何对其进行编码   |
| target  | _blank<br/>_self<br/>_parent<br/>_top<br/>framename          | 规定在何处打开action URL                 |

![image-20220523201442095](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220523201442095.png)

#### 1.action

action属性用来规定当提交表单时,**向何处发送表单数据**。

action属性的值应该是后端提供的一个URL地址,这个URL地址专门负责接收表单提交过来的数据。

当<form>表单在未指定action属性值的情况下，action 的默认值为当前页面的URL地址。

**注意:**当提交表单后，页面会立即跳转到action属性指定的URL地址

#### 2.target

target属性用来规定**在何处打开action URL**。

它的可选值有5个，默认情况下，target 的值是_ self, 表示在相同的框架中打开action URL。

| 值        | 描述                         |
| --------- | ---------------------------- |
| _blank    | 在新窗口中打开               |
| _self     | 默认。在相同的框架中打开     |
| _parent   | 在父框架集中打开。(很少用)   |
| _top      | 在整个窗口中打开。(很少用)   |
| framename | 在指定的框架中打开。(很少用) |

#### 3.method

method属性用来规定**以何种方式**把表单数据提交到action URL。

它的可选值有两个，分别是get和post.

默认情况下，method的值为get,表示通过URL地址的形式，把表单数据提交到action URL.

```js
<form action='/login' target='_blank' method='GET'> // get可以大小写
<input type="text" name="email_ or_ mobile" />
<input type="password" name="password" />
<input type="checkbox" name=" remember_ me" checked />
<button type="submit">提交</button>
</form>
```

![image-20220523212635511](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220523212635511.png)



- ? 分隔action URL地址(/login) 和具体的数据  
- 多个数据之间用&隔开 
- 数据名=数据值



```js
<form action='/login' target='_blank' method='POST'> // get,post可以大小写
<input type="text" name="email_ or_ mobile" />
<input type="password" name="password" />
<input type="checkbox" name=" remember_ me" checked />
<button type="submit">提交</button>
</form>
```

method的值为post, 隐秘的方式提交的，安全性比get方式的高。

提交的数据不会出现在action URL栏里面

**注意:**

get方式适合用来提交少量的、简单的数据。

post方式适合用来提交**大量的、复杂的**、或包含**文件上传**的数据。

在实际开发中，<form> 表单的post提交方式用的最多，很少用get。例如登录、注册、添

加数据等表单操作,都需要使用post方式来提交表单。

#### 4.enctype

enctype属性用来规定在**发送表单数据之前如何对数据进行编码**。

它的可选值有三个，默认情况下，enctype 的值为application/x-www-form-urlencoded,表示在发送前编码所有的字符。

| 值                                | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| application/x-www-form-urlencoded | 在发送前编码所有字符(默认)                                   |
| multipart/form-data               | 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 |
| text/plain                        | 空格转换为"+" 加号，但不对特殊字符编码。(很少用)             |

**注意:**
在涉及到**文件上传**的操作时，**必须**将enctype的值设置为**multipart/form-data**

如果表单的提交不涉及到文件上传操作，则直接将enctype的值设置为application/x-www-form-urlencoded即可!

### 1.4 表单的同步提交及缺点

#### 1.什么是表单的同步提交

通过点击submit按钮，触发表单提交的操作，从而使页面跳转到action URL的行为，叫做表单的同步提交。

#### 2.表单同步提交的缺点

​	①<form>表单同步提交后， 整个页面会发生跳转,**跳转到action URL所指向的地址**，用户体验很差。
​	②<form> 表单同步提交后，**页面之前的状态和数据会丢失**。

#### 3.如何解决表单同步提交的缺点

如果使用表单提交数据，则会导致以下两个问题:

​	①页面会发生跳转

​	②页面之 前的状态和数据会丢失

解决方案:**表单只负责采集数据，Ajax负责将数据提交到服务器**。

## 2.通过Ajax提交表单数据

### 2.1 监听表单提交事件

在Jquery中，可以使用2如下两种方式，监听到表单的提交事件

```html
<form action="/login" id="f1">
        <input type="text" name="email_ or_ mobile" />
        <input type="password" name="password" />
        <input type="checkbox" name=" remember_ me" checked />
        <button type="submit">提交</button>
    </form>
    <script>
        $(function () {
            // 第一种
            // $("#f1").submit(function () {
            //     alert('监听到了表单的提交事件')
            // })

            // 第二种
            $("#f1").on("submit", function () {
                alert('监听到了表单的提交事件')
            })
        })
    </script>
```

### 2.2 阻止表单默认提交行为

表单要是我们点击了提交以后，必然会跳转到action 所指定的URL地址，这就是表单的默认行为。

当监听到表单的提交事件以后，可以调用事件对象的event.preventDefault()函数,来阻止表单的提交和页面的跳转,示例代码如下:

```js
			// 第一种
            $("#f1").submit(function (e) {
                alert('监听到了表单的提交事件')
                e.preventDefault();
            })

            // 第二种
            $("#f1").on("submit", function (e) {
                alert('监听到了表单的提交事件')
                e.preventDefault();
            })
```

### 2.3 快速获取表单中的数据

#### 1.serialize()函数

为了简化表单中数据的获取操作，jQuery提供了serialize()函数，其语法格式如下：

```js
$(selector).serialize()
```

serialize()函数的好处：**可以一次性获取到表单中的所有的数据**。

#### 2.serialize()函数示例

```html
 <form action="/login" id="form1">
        <input type="text" name="username" />
        <input type="password" name="password" />
        <button type="submit">提交</button>
    </form>
```

```js
$('#form1').serialize ()
//调用的结果:
// username=用户名的值&password=密码的值
```

注意:在使用serialize()函数快速获取表单数据时,**必须为每个表单元素添加name属性**!

![image-20220524094912948](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524094912948.png)

## 3.案列-评论列表

### 3.1 渲染UI结构

![image-20220524104914386](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524104914386.png)

### 3.2 评论列表接口文档

![image-20220524105140604](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524105140604.png)

![image-20220524104803102](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524104803102.png)

![image-20220524104836212](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524104836212.png)

### 3.3 发表评论文档

![image-20220524144156618](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524144156618.png)

### 3.4 表单内容原生重置函数reset()

```js
$("#formAddCmt").submit(function (e) {
        e.preventDefault();
        var data = $(this).serialize();
        $.post('http://www.liulongbin.top:3006/api/addcmt', data, function (res) {
            if (res.status !== 201) return alert('列表获取失败');
            // 渲染到页面上
            getCommentList();
            // 把jQuery转换为原生js 再使用原生js的DOM对象 利用表单form的reset函数重置表单的内容
            $("#formAddCmt")[0].reset();
        })
    })
```

## 4.模板引擎的基本概念

### 4.1 渲染UI结构时遇到的问题

```js
var rows = [];
$.each(res.data, function(index, Element) {
	rows.push('<li class="list-group-item">'+Element.content+'<span class="bandge cmt-data">评论时间: '+Element.time+'</span><span class="bandge cmt-person">评论人: '+Element.username+'</span></li>')
})
```

上述代码是通过字符串拼接的形式，来渲染UI结构。
如果UI结构比较复杂，则拼接字符串的时候需要格外注意引号之前的嵌套。且一旦需求发生变化，修改起来也非常麻烦。

### 4.2 什么是模板引擎

模板引擎,顾名思义，它可以根据程序员指定的**模板结构**和**数据**，自动生成一个完整的HTML页面。

![image-20220524172134254](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524172134254.png)

### 4.3 模板引擎的好处

1. 减少了字符串的拼接操作
2. 使代码结构更清晰
3. 使代码更易于阅读与维护

## 5.art-template模板引擎

### 5.1 art-template简介

![image-20220524193111644](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524193111644.png)

### 5.2 art-template的安装

在浏览器中访问http://aui.github.io/art-template/zh-cn/docs/installation.html页面,找到下载链接后，鼠标右键,选择”链接另存为”,将art-template下载到本地，然后,通过<script>标签加载到网页上进行使用。

![image-20220524193331990](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524193331990.png)

### 5.3 art-template模板引擎的基本使用

#### 1.使用传统方式渲染UI结构

![image-20220524193703831](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220524193703831.png)

```html
 <div id="title"></div>
    <div id="age">年龄: <span></span></div>
    <div id="isVIP">会员: <span></span></div>
    <div id="regTime">注册时间: <span></span></div>
    <div id="hobby">爱好:
        <ul>
            <li>爱好1</li>
            <li>爱好2</li>
            <li>爱好3</li>
        </ul>
    </div>
    <script>
        var data = {
            title: '<h3>用户信息</h3>',
            name: 'zs',
            age: 20,
            isVIP: true,
            regTime: new Date(),
            hobby: ['吃饭', '睡觉', '打豆豆', '打手虫']
        };

        $(function () {
            $("#title").html(data.title);
            $("#age span").html(data.age);
            $("#isVIP span").html(data.isVIP);
            $("#regTime span").html(data.regTime);
            var rows = [];
            $.each(data.hobby, function (index, Element) {
                rows.push("<li>" + Element + "</li>")
            })
            $("#hobby ul").empty().append(rows.join(""));
        })
    </script>
```

#### 2.art-template的使用步骤

1. 导入art-template
2. 定义数据
3. 定义模板
4. 调用template函数
5. 渲染HTML结构

注意：导入了art-template模板 window全局就会有template函数，叫做template('模板的ID', 需要渲染的数据对象)就像jQuery一样

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 1.导入模板 -->
    <script src="./js/template-web.js"></script>
    <script src="./js/jQuery.min.js"></script>
    <title>Document</title>
</head>

<body>
    <div id="container"></div>
    <!-- 3.定义模板 -->
    <!-- 3.1 模板的 HTML 的结构，必须定义到 script 中  -->
    <!-- 因为普通的script标签有个默认的type类型 为text/script  -->
    <script type="text/html" id="tpl-user">
        <!-- {{}} 是art-template提供的一个语法 相当于占位符 -->
        <h1>{{name}}  ------  {{age}}</h1> 
    </script>
    <script>
        // 2.定义数据
        var data = { name: 'zs', age: 18 }

        // 4.调用 template 函数
        // template('模板的id', 需要渲染到页面的数据)  模板id那里不需要加 #
        var HTMLstr = template("tpl-user", data);
        // 5.渲染到html页面中
        $("#container").html(HTMLstr);
    </script>
</body>

</html>
```

### 5.4 art-template标准语法

#### 1.什么是标准语法

art-template提供了{{ }}这种语法格式，在{{ }}内可以进行**变量输出**，或**循环数组**等操作,这种{{ }}语法在art-template中被称为标准语法。

#### 2.标准语法 - 输出

```js
{{value}}
{{obj.key}}
{{obj['key']}}
{{a ? b : c}}
{{a || b}}
{{a + b}}
```

在{{ }}语法中，可以进行**变量**的输出、**对象属性**的输出、**三元表达式**输出、**逻辑或**输出、**加减乘除等表达式**输出。

#### 3.标准语法 - 原文输出

```js
{{@ value}}
```

如果要输出的value值中，包含了HTML标签结构，则需要使用**原文输出**语法，才能保证HTML标签被正常渲染。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 1.导入模板 -->
    <script src="./js/template-web.js"></script>
    <script src="./js/jQuery.min.js"></script>
    <title>Document</title>
</head>

<body>
    <div id="container"></div>
    <!-- 3.定义模板 -->
    <!-- 3.1 模板的 HTML 的结构，必须定义到 script 中  -->
    <!-- 因为普通的script标签有个默认的type类型 为text/script  -->
    <script type="text/html" id="tpl-user">
        <!-- {{}} 是art-template提供的一个语法 相当于占位符 -->
    <h1>{{name}} ------ {{age}}</h1>
    {{@ text}}
    </script>
    <script>
        // 2.定义数据
        var data = { name: 'zs', age: 18, text: '<h3>原文输出测试</h3>' }

        // 4.调用 template 函数
        // template('模板的id', 需要渲染到页面的数据)  模板id那里不需要加 #
        var HTMLstr = template("tpl-user", data);
        // 5.渲染到html页面中
        $("#container").html(HTMLstr);
    </script>
</body>

</html>
```

#### 4.标准语法 - 条件输出

如果要实现条件输出，则可以在{{}}中使用if ... else if ...  /if的方式，进行按需输出。

```js
{{if value}} 按需输出的内容 {{/if}}
                       
{{if v1}} 按需输出的内容 {{else if v2}} 按需输出的内容 {{/if}}
```

#### 5.标准语法 - 循环输出

如果要实现循环输出，则可以在{{}}内，通过each语法循环数组，当前循环的索引号使用$index进行访问,当前的循环项使用$value进行访问。

```js
{{each arr}}
 {{$index}} {{$value}}
 {{/each}}
```

```html
		<ul>
            {{each hobby}}
            <li>索引号是: {{$index}} 索引项是: {{$value}}</li>
            {{/each}}
        </ul>
```

#### 6.标准语法 - 过滤器

![image-20220525090435376](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220525090435376.png)

过滤器的本质，就是一个function处理函数。

```
{{value | filterName}}  // filterName 这个名字是自定义的(过滤器函数名)
```

过滤器语法类似**管道操作符**，它的上一个输出作为下一个输入。

定义过滤器的基本语法如下：

```js
template.defaults.imports.filterName = function (value) { /* return处理的结果 */} // 这里的value是形参 由管道操作符前面的那个value传过来 这里return的结果就会{{}} 里面显示
```

**实例：**

```html
<div>注册时间: {{regTime | dataFormat}}</div>
```

定义一个格式化时间的过滤器dataFormat如下：

```js
template.defaults.imports.dataFormat = function(data) {
	var y = data.getFullYear();
	var m = data.getMonth();
	var d = data.getDate();
	return y + '-' + m + '-' + d // 注意: 过滤器最后一定要 return 一个值
}
```

### 5.5 案列 - 新闻列表

![image-20220525100857423](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220525100857423.png)

#### 1.新闻列表的接口文档

![image-20220525101018349](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220525101018349.png)

![image-20220525151046697](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220525151046697.png)

#### 2.实现步骤

1. 获取新闻数据
2. 定义template模板.
3. 编译模板
4. 定义时间过滤器
5. 定义补零函数

## 6.模板引擎的实现原理

### 6.1 正则与字符串操作

#### 1.基本语法

exec()函数用于**检索字符串**中的正则表达式的匹配。

如果字符串中有匹配的值，**则返回该匹配值,**否则返回**null**.

```js
RegExpObject.exec(string)
```

示例

```js
var str = 'hello';
var pattern = /o/;
consloe(pattern.exec(str)) // 输出的结果 {’o’, index: 4, input: 'hello', grroups: 'undefined'}
```

#### 2.分组

正则表达式中()包起来的内容表示一个分组， 可以通过分组来**提取自己想要的内容**,示例代码如下: 

```js
var str = '<div>我是{{name}}</div>' // {{}} 占位符
var pattern = /{{([a-zA-Z]+)}}/  // {{在这里写的正则表达式与str里面的{{}}相匹配}}

var patternResult = pattern.exec(str)
console.log(patternResult) 
// 得到 name 相关的分组信息
// {"{{name}}", "name", index: 7. input: "<div>我是{{name}}</div>", groupe: undefined}
```

#### 3.字符串的replace函数

replace()函数用于在字符串中用一些字符**替换**另一些字符，语法格式如下:

```js
var result = '123456'.replace('123', 'abc'); // 得到的result的值为字符串 ’abc456
```

示例代码如下：

```js
var str = '<div>我是{{name}}</div>'
var pattern = /{{([a-zA-Z]+)}}/
var patternResult = pattern.exec(str)
利用字符串的replace函数 把patternResult里面的第一项 替换为 第二项
str = str.replace(patternResult[0], patternResule[1])
console.log(str)
```

#### 4.字符串的多次replace

```js
 var str = '<div>{{name}}今年已经{{ age }}岁啦!</div>'
        var pattern = /{{\s*([a-zA-Z]+)\s*}}/ // \s表示空白 *表示一次或多次

        // 第一次匹配
        var res1 = pattern.exec(str);
        str = str.replace(res1[0], res1[1])
        console.log(str); // 输出 <div>name今年已经{{ age }}岁啦!</div>

        // 第二次匹配
        var res2 = pattern.exec(str)
        str = str.replace(res2[0], res2[1])
        console.log(str); // 输出 <div>name今年已经age岁啦!</div>

        // 第三次匹配
        var res3 = pattern.exec(str)
        str = str.replace(res3[0], res[1])
        console.log(str); // 输出 null 就表示已经匹配完了 没必要再匹配了
```

#### 5.使用while循环replace

```js
var str = '<div>{{name}}今年{{ age }}岁啦/div>'
        var pattern = /{{\s*([a-zA-Z]+)\s*}}/

        var patternResult = null // 先声明patternReuslt的值为null
        while (patternResult = pattern.exec(str)) { // 当匹配完毕后，patternResult的值再为null的时候就停止循环
            str = str.replace(patternResult[0], patternResult[1])

        }
        console.log(str);
    </script>
```

#### 6.replace替换为真值

```js
var data = { name: '张三', age: 18 }
        var str = '<div>{{name}}今年已经{{ age }}岁啦!</div>'
        var pattern = /{{\s*([a-zA-Z]+)\s*}}/

        var patternResult = null
        while (patternResult = pattern.exec(str)) {
            str = str.replace(patternResult[0], data[patternResult[1]]) // patternResult[1] 就是name 或者 age data[age]就是调用对象的的属性值了
        }
       console.log(str)
```

### 6.2 实现简易的模板引擎

#### 1.实现步骤

1. 定义模板结构
2. 预调用模板引擎
3. 封装template函数
4. 导入并使用自定义的模板引擎

#### 2.定义模板结构

```html
// 定义模板结构
<script type="text/html" id=”tpl-user>
	<div>姓名: {{name}}</div>
	<div>年龄: {{ age }}</div>
	<div>性别: {{  gender}}</div>
	<div>住址: {{address  }}</div>
</script>
```

#### 3.预调用模板引擎

```js
<!-- 2.预调用模板引擎 -->
    <script>
        // 2.1 定义数据
        var data = { name: '张三', age: 18, gender: '男', address: '北京顺义马坡' }

        // 2.2 调用模板函数
        // template('模板id(不需要加#)', 需要渲染的数据)
        var htmlStr = template('tpl-user', data)

        // 2.3 渲染到html结构上
        document.getElementById('user-box').innerHTML = htmlStr
    </script>
```

#### 4.封装自定义的template函数

```js
function template(id, data) {
    var str = document.getElementById(id).innerHTML
    var pattern = /{{\s*([a-zA-Z]+)\s*}}/

    var patternResult = null
    while (patternResult = pattern.exec(str)) {
        str = str.replace(patternResult[0], data[patternResult[1]])
    }
    return str;
}
```

在调用的时候要写在预调用模板函数前面，因为有了template函数 才能调用自定义template函数

#### 5.导入并使用自定义的模板引擎

```js
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 调用自定义模板引擎 -->
    <script src="./js/20.template.js"></script>
    <title>Document</title>
</head>
```

# 三、Ajax加强

## 1.XMLHttpRequest的基本使用

### 1.1 什么是XMLHttpRequest

XMLHttpRequest (简称xhr)是浏览器提供的Javascript对象,通过它,可以**请求服务器上的数据资**

**源**。之前所学的jQuery中的Ajax函数,就是基于xhr对象封装出来的。

![image-20220526160723092](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220526160723092.png)

可以直接使用xhr对象发起Ajax请求，但是比较麻烦

### 1.2 使用xhr发起GET请求

步骤：

​	①创建xhr对象

​	②调用xhr.open(函数

​	③调用xhr.send0函数

​	④监听xhr.onreadystatechange事件

```js
//1.创建XHR对象
	var xhr = new XMLHttpRequest()
// 2.调用open函数，指定请求方式与URL地址
	xhr.open('GET', 'http:/ /www. liulongbin. top: 3006/ api/getbooks')
//3. 调用send函数，发起Ajax请求
	xhr.send()
// 4.监听onreadystatechange 事件
	xhr.onreadystatechange = function() {
		// 4.1 监听xhr对象的请求状态readyState ;与服务器响应的状态 status 固定写法
        if (xhr.readyState === 4 && xhr.status === 200) {
				// 4.2打印服务器响应回来的数据
			console.log (xhr.responseText)
}
}

```

**注意：**

监听事件里面的 status 与 服务器响应回来的数据里面的 status是不一样的

监听事件里面的status 是 整个http请求数据的一部分

服务器响应回来的status 属于 服务器响应回来数据的一部分

### 1.3 了解xhr对象的readyState属性

XMLHttpRequest对象的readyState属性，用来表示**当前Ajax请求所处的状态**。每个Ajax请求必然

处于以下状态中的一一个: .

| 值   | 状态             | 描述                                             |
| ---- | ---------------- | ------------------------------------------------ |
| 0    | UNSENT           | XMLHttpRequest对象已被创建，但未调用open方法     |
| 1    | OPENED           | open()方法已经被调用                             |
| 2    | HEADERS_RECEIVED | send()方法已经被调用，响应头也已经被接收         |
| 3    | LOADING          | 数据接收中，此时response属性中已经包含部分数据   |
| 4    | DONE             | Ajax请求完成，这意味着数据传输已经彻底完成或失败 |

### 1.4 使用xhr发起带参数的GET请求

使用xhr对象发起带参数的GET请求时，只需在调用xhr.open期间，为URL地址指定参数即可:

```
// ...省略不必要的代码
	xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks?id=1')
	// ?前面是URL地址 后面是参数，参数采取键值对的方式， 如果多个参数 中间用&相连 例 ?id=1&name=3
// ...省略不必要的代码
```

这种在URL地址后面拼接的参数，叫做**查询字符串**

### 1.5 查询字符串

#### 1.什么是查询字符串

定义: 查询字符串(URL 参数)是指在URL的末尾加上用于向服务器发送信息的字符串(变量)。

格式: 将英文的 ? 放在URL的末尾，然后再加上**参数=值**(键值对的形式)，想加上多个参数的话，使用

**&**符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到URL中。

```
// 不带参数的 URL 地址
http://www.liulongbin.top:3006/api/getbooks
// 带一个参数的URL 地址
http://www.liulongbin.top:3006/api/getbooks?id=1
// 带两个参数的 URL 地址
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
```

#### 2.GET请求携带参数的本质

无论使用$.ajax(),还是使用$.get(),又或者直接使用xhr对象发起GET请求,当需要携带参数的时候,本质

上，都是直接将参数以查询字符串的形式，追加到URL地址的后面，发送到服务器的。

```js
$.get('url', {name: 'zs', age: 18}, function(res){ }) 
// 等价于
$.get('url?name=zs&age=18', function(res) { })

$.ajax({type: 'GET', 'url', data: {name: 'zs', age: 18}, success: function(res) { }  })
// 等价于
$.ajax({type: 'GET', 'url?name=zs&age=18', success: function(res) {}   })
```

![image-20220526190729582](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220526190729582.png)

### 1.6 URL编码与解码

#### 1.什么是URL编码

URL地址中，只允许出现英文相关的字母、标点符号、数字，因此,在URL地址中不允许出现中文字符。

如果URL中需要包含中文这样的字符，则必须对中文字符进行**编码**(转义) 。

URL编码的原则:使用安全的字符(没有特殊用途或者特殊意义的可打印字符)去表示那些不安全的字符。

URL编码原则的通俗理解: 使用**英文字符**去表示**非英文字符**。

```
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
//经过URL编码之后，URL地址变成了如下格式: 
http://www.liulongbin.top:3006/api/getbooks?id=1 &bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0
```

![image-20220526192935422](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220526192935422.png)

#### 2.如何对URL进行编码与解码

浏览器提供了URL编码与解码的API,分别是:

- encodeURI() 编码的函数
- decodeURI() 解码的函数

```js
encodeURL('黑马程序员')
// 输出字符串 %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98
decodeURL('%E9%BB%91%E9%A9%AC')
// 输出字符串 黑马
```

#### 3.URL编码的注意事项

由于浏览器会自动对URL地址进行编码操作，因此，大多数情况下，程序员不需要关心URL地址的编码与解码操作。

更多关于URL编码的知识，请参考如下博客:
https://blog.csdn.net/Lxd_0111/article/details/78028889

### 1.7 使用xhr发起POST请求

步骤：

​	①创建xhr对象
​	②调用xhr.open()函数
​	③设置Content-Type属性(固定写法)
​	④调用xhr.send()函数，同时指定要发送的数据
​	⑤监听xhr.onreadystatechange事件

```js
		// 1.创建 xhr 对象
        var xhr = new XMLHttpRequest();
        // 2.调用 open() 方法 调用方式与URL地址
        xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
        // 3.设置Content-Type 属性 (固定写法)
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        // 4.调用 send() 同时将数据以查询字符串的形式，提交给服务器
        xhr.send('bookname=水浒传&author=施耐庵&publisher=天津图书出版社')
        // 5.监听 onreadystatechange 事件
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText);
            }
        }

```

## 2.数据交换格式

### 2.1 什么是数据交换格式

数据交换格式，就是**服务器端**与**客户端**之间进行**数据传输与交换的格式**。

前端领域，经常提及的两种数据交换格式分别是XML和JSON。其中XML用的非常少，所以，我们重点要学习的数据交换格式就是JSON。

![image-20220527085702509](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220527085702509.png)

### 2.2 XML

#### 1.什么是XML

XML的英文全称是EXtensible Markup Language,即**可扩展标记语言**。因此，XML和HTML类似,
也是一-种标记语言。

![image-20220527090003792](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220527090003792.png)

XML的语义化比较强

#### 2.XML和HTML的区别

XML和HTML虽然都是标记语言，但是，它们两者之间没有任何的关系。

- HTML被设计用来描述网页上的内容,是网页内容的载体
- XML被设计用来传输和存储数据，是数据的载体

![image-20220527090303455](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220527090303455.png)

#### 3.XML的缺点

​	① XML格式臃肿,和数据无关的代码多,体积大，传输效率低

​	② 在Javascript中解析XML比较麻烦

### 2.3 JSON

#### 1.什么是JSON

概念: JSON的英文全称是JavaScript Object Notation,即"JavaScript 对象表示法”。简单来讲,
JSON就是Javascript对象和数组的字符串表示法，它使用文本表示一个JS对象或数组的信息，因此,
**JSON的本质是字符串。**

作用: JSON是一种**轻量级的文本数据交换格式**，在作用上类似于XML,专门用于存储和传输数据,但
是JSON比XML更小、更快、更易解析。

现状: JSON是在2001年开始被推广和使用的数据格式，到现今为止，JSON已经成为了主流的数据交
换格式。
心

#### 2.JSON的两种结构

JSON就是用字符串来表示Javascript的对象和数组。所以，JSON中包含对象和数组两种结构，通过这两种结构的**相互嵌套**， 可以表示各种复杂的数据结构。

##### **对象结构：**

对象结构: 对象结构在JSON中表示为{ } 括起来的内容。数据结构为{ key: value, key: value, ..}的键
值对结构。其中，key必须是使用**英文的双引号**包裹的字符串, value的数据类型可以是数字、字符串、布尔值、null、 数组、对象6种类型。

**注意：**value如果为字符串 则也要使用英文的双引号

![image-20220527092829987](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220527092829987.png)

##### 数组结构：

数组结构: 数组结构在JSON中表示为 [] 括起来的内容。数据结构为[ "java", "javascript", 30, true ..]。数组中数据的类型可以是数字、字符串、布尔值、null、 数组、对象6种类型。

```js
[ "java", "python", "php" ]
[ 100， 200， 300.5 ]
[ true, false, null ]
[ { "name ": "zs"，"age": 20}, { "name": "ls", "age": 30} ]
[ [ "苹果"，"榴莲"，"椰子"]，[4，50，5]]

```

#### 3.JSON语法注意事项

​	① 属性名必须使用双引号包裹

​	② 字符串类型的值必须使用双引号包裹

​	③ JSON中不允许使用单引|号表示字符串

​	④ JSON中不能写注释

​	⑤ JSON的最外层必须是对象或数组格式

​	⑥ 不能使用undefined或函数作为JSON的值

**JSON的作用**:在计算机与网络之间存储和传输数据。

**JSON的本质:**用字符串来表示Javascript对象数据或数组数据

#### 4.JSON和JS对象的关系

JSON是JS对象的字符串表示法,它使用文本表示一个JS对象的信息,本质是一个字符串。 例如:

```js
// 这是一个对象
var obj = {a: 'Hello', b: 'World'}

// 这是一个 JSON 字符串，本质是一个字符串
var json = '{"a", "Hello", "b": "World"}'
```

#### 5.JSON和JS对象的互转

要实现从JSON字符串转换为JS对象，使用JSON.parse()方法: 

```js
var obj = JSON.parse('{"a": "Hello", "b": "World"}')
//结果是 {a: 'Hello', b: 'World' }
```

要实现从JS对象转换为JSON字符串，使用JSON.stringify()方法:

```js
var json = JSON.stringify({a: 'Hello' , b: 'World' })
//结果是'{"a": "Hello", "bh: "World"} '
```

###### 演示JSON.parse函数的应用场景

```js
var xhr = new XMLHttpRequest()
        xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
        xhr.send()
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText); // 打印出来的是 json 格式 的字符串
                var obj = JSON.parse(xhr.responseText)
                console.log(obj);
            }

        }
```

#### 6.序列化和反序列化

把数据对象转换为字符串的过程，叫做序列化,例如:调用JSON.stringify()函数的操作，叫做JSON序列化。
把字符串转换为数据对象的过程，叫做反序列化，例如:调用JSON.parse()函数的操作，叫做JSON反序列化。

## 3.封装自己的Ajax函数

### 3.1 要实现的效果

```ht
<!-- 1.导入自定义的ajax函数库-->
<script src="./itheima.js"></ script>

<script>
// 2.调用自定义的itheima 函数，发起Ajax数据请求
itheima ({
	method: '请求类型'，
	url: '请求地址' ，
	data: { /*请求参数对象*/ },
	success: function(res) { // 成功的回调函数
			console. log (res) //打印数据
}
})
</script>

```

### 3.2 定义options参数选项

itheima()函数是我们自定义的Ajax函数，它接收一个配置对象作为参数，配置对象中可以配置如下属性:

- method	请求的类型
- url	         请求的URL地址
- data	      请求携带的数据
- success    请求成功之后的回调函数

### 3.3 处理data参数

需要把data对象，转化成查询字符串的格式，从而提前定义 resolveData函数如下：

```js
/**
 * 处理 data 参数
 * @param {data} 需要发送到服务器的数据
 * @returns {string} 返回拼接好的查询字符串 name=zs&age=10
 */
function resolveData(data) {
    var arr = []
    for (let k in data) {
		arr.push(k + '=' + data[k])
    }
    return arr.join("&")
}
```

### 3.4 定义itheima函数

zaiitheimma() 函数中，需要创建 xhr 对象，并监听 onreadystatechange 事件：

```js
function itheima(options) {
    var xhr = new XMLHttpRequest()

    // 把外界传递过来的参数对象，转化哪位 查询字符串
    var qs = resolveData(options.data)

    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
            var result = JSON.parse(xhr.responseText)
            options.success(result) // 因为在succsee函数中 用户指定了要进行哪些操作  它的操作要依赖于我们服务器响应回来的数据
        }
    }
}
```

### 3.5 判断请求的类型

不同的请求类型，对应xhr对象的不同操作，因此需要对请求类型进行if ...else ...的判断

```js
if (options.method.toUpperCase() === 'GET') {
        // 发起 GET 请求
        xhr.open(options.method, options.url)
        xhr.send()
   } else if (options.method.toUpperCase() === 'POST') {
        // 发起 POST 请求
        xhr.open(options.method, options.url)
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
        xhr.send(qs)
    }

```

### 3.6 测试 自己封装的Ajax函数

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./js/27.itheima.js"></script>
    <title>Document</title>
</head>

<body>
    <script>
        // itheima({
        //     method: 'GET',
        //     url: 'http://liulongbin.top:3006/api/getbooks',
        //     // data: {
        //     //     id: 1
        //     // },
        //     success: function (res) {
        //         console.log(res);
        //     }
        // })

        itheima({
            method: 'POST',
            url: 'http://www.liulongbin.top:3006/api/addbook',
            data: {
                bookname: '红宝书',
                author: '扎卡斯',
                publisher: '上海图书出版社'
            },
            success: function (res) {
                console.log(res);
            }
        })
    </script>
</body>

</html>
```

## 4.XMLHttprequest Level2的新特性

### 4.1 认识 XMLHttprequest Level2

#### 1.旧版XMLHttpRequest的缺点

​	① 只支持文本数据的传输，无法用来读取和上传文件

​	②传送和接收数据时，没有进度信息，只能提示有没有完成

#### 2.XMLHttpRequest Level2的新功能

​	① 可以设置HTTP请求的时限

​	② 可以使用FormData对象管理表单数据

​	③ 可以上传文件

​	④ 可以获得数据传输的进度信息

### 4.2 设置HTTP请求时限

有时，Ajax操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的XMLHttpRequest对象，增加了timeout 属性，可以设置HTTP请求的时限: 

```js
var xhr = new XMLHttpRequest()
xhr.timeout = 3000 // 单位是毫秒
```

上面的语句，将最长等待时间设为3000毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout事件,用来指定回调函数:

```js
xhr.ontimeout = function (event) {
	alert( '请求超时! ')
}
```

示例：

```js4.
 var xhr = new XMLHttpRequest();
        // 设置超时时限
        xhr.timeout = 300;
        // 设置超时以后的处理函数
        xhr.ontimeout = function () {
            console.log('请求超时了!');
        }
        xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
        xhr.send()

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText);
            }
        }
```

### 4.3 FormData对象管理表单数据

#### 1.FormData对象基本使用

Ajax操作往往用来提交表单数据。为了方便表单处理，HTML5新增了一个FormData对象，可以模拟表单操作：

```js
		// 1.新建 FormData 对象
        var fd = new FormData();
        // 2.为 FormData 添加表单项
        fd.append('uname', 'zs');
        fd.append('upwd', '123456')
        // 3.创建 XML 对象
        var xhr = new XMLHttpRequest()
        // 4.指定请求类型与URL地址
        xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
        // 5.直接提交 FormData 对象， 这与提交网页表单的效果，完全一样

        xhr.send(fd)
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                console.log(xhr.responseText);
            }
        }
```

#### 2.FormData对象的示例

FormData对象也可以用来获取网页表单的值，实例代码如下：

``` html
 <form id="form">
        <input type="text" name="uname" autocomplete="off" />
        <input type="password" name="upwd" />
        <button type="submit">提交</button>
    </form>
    <script>
        // 获取表单元素
        var form = document.querySelector("#form")
        // 监听表单元素的 submit 事件
        form.addEventListener("submit", function (e) {
            // 阻止表单的默认提交行为
            e.preventDefault()
            // 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中
            var fd = new FormData(form)
            var xhr = new XMLHttpRequest()
            xhr.open("POST", 'http://www.liulongbin.top:3006/api/formdata')
            xhr.send(fd)
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    console.log(JSON.parse(xhr.responseText));

                }
            }
        })
    </script>



```

### 4.4 上传文件

新版XMLHttpRequest对象，不仅可以发送文本信息，还可以上传文件。

实现步骤：

​	① 定义UI结构.

​	② 验证是否选择了文件

​	③ 向FormData中追加文件

​	④ 使用xhr发起上传文件的请求

​	⑤ 监听onreadystatechange事件

#### 1.定义UI结构

```html
// 1.文件选择框
<input type="file" id="file1" />
// 2.上传文件的按钮
<button id="btnUpload">上传文件</button>
// 3.img标签 来显示上传成功以后的图片
<img src="" alt="" id="img" width="800" />
```

#### 2.验证是否选择了文件

```js
// 1.获取上传文件的按钮
var btnUpload = document.querySelector('#btnUpload')
// 2.为按钮添加 click 事件监听
btnUpload.addEventListener('click', function() {
    // 3.获取到选择的文件列表
   var filess = document.querySelector("#filel").files
   // files就是文件的数组
    if (filess.length <= 0) {
        return alert('请选择要上传的文件!')
    }
}
```

#### 3.向FormData中追加文件

```js
// 1.创建 FormData 对象
var fd = new FormData()
// 2.向 FormData 中追加文件
fd.append('avatar', filess[0])
```

#### 4.使用xhr发起上传文件的请求

```js
// 1.创建 xhr 对象
var xhr = new XMLHttpRequest()
// 2,调用 open 函数，指定请求类型与URL地址，其中 请求类型必须为 POST
xhr.open("POST", 'http://www.liulongbin.top:3006/api/upload/avatar')
// 3.发起请求
xhr.send(fd)
```

#### 5.监听onreadystatechange事件

```js
xhr.onreadystatechange = function() {
	if (xhr.readyState === 4 && xhr.status === 200) {
		var data = JSON.parse(xhr.responseText)
        if (data.status === 200) { // 上传成功
            // 将服务器返回的图片地址，设置为 <img> 标签的src属性
            document.querySelector("#img").src = 'http://www.liulongbin.top:3006' + data.url
        } else { // 上传失败
            consloe.log(data.message)
            
        }
            
	}
}
```

#### 6.综合

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 1.文件选择框 -->
    <input type="file" id="file1">
    <!-- 2.上传文件的按钮 -->
    <button id="btnUpload">上传文件</button>
    <!-- 3.img标签 来显示上传成功以后的图片 -->
    <img src="" alt="" id="img" width="800" />
</body>
<script>
    // 1.获取上传文件的按钮
    var btnUPload = document.querySelector("#btnUpload")
    // 2.为按钮添加 click 事件监听
    btnUPload.addEventListener("click", function () {
        // 3.获取到选择的文件列表
        var filess = document.querySelector("#file1").files
        // files就是文件的数组
        if (filess.length <= 0) {
            return alert('请选择要上传的文件!')
        }

        var fd = new FormData()
        // 将用户选择的文件，添加到 FormData 中
        fd.append("avatar", filess[0])

        var xhr = new XMLHttpRequest()
        xhr.open("POST", 'http://www.liulongbin.top:3006/api/upload/avatar')
        xhr.send(fd)

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                var data = JSON.parse(xhr.responseText)

                if (data.status === 200) { // 上传成功
                    document.querySelector("#img").src = 'http://www.liulongbin.top:3006' + data.url

                } else { // 上传失败
                    console.log(data.message);

                }
            }


        }
    })
</script>

</html>
```

### 4.5 显示文件上传进度

新版本的XMLHttpRequest对象中，可以通过监听xhr.upload.onprogress事件,来获取到文件的上传进度。

在控制台打印文件上传进度的时候，可以先去Network面板改一下网速，这样会清楚一些

![image-20220528170827120](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220528170827120.png)

语法格式如下:

```js
// 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 监听 xhr.upload 的 onprogress 事件
xhr.upload.onprogress = function(e) {
    // e.lengthComputable 是一个布尔值 表示当前上传的资源是否具有可计算的长度
    if (e.lengthComputable) {
        // e.loaded 已传输的字节
        // e.total 需传输的总字节
      var percentComplete = Math.ceil((e.loaded / e.total) * 100)
    }
}
```



#### **示例**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 1.文件选择框 -->
    <input type="file" id="file1">
    <!-- 2.上传文件的按钮 -->
    <button id="btnUpload">上传文件</button>
    <br />
    <!-- 3.img标签 来显示上传成功以后的图片 -->
    <img src="" alt="" id="img" width="800" />
</body>
<script>
    // 1.获取上传文件的按钮
    var btnUPload = document.querySelector("#btnUpload")
    // 2.为按钮添加 click 事件监听
    btnUPload.addEventListener("click", function () {
        // 3.获取到选择的文件列表
        var filess = document.querySelector("#file1").files
        // files就是文件的数组
        if (filess.length <= 0) {
            return alert('请选择要上传的文件!')
        }

        var fd = new FormData()
        // 将用户选择的文件，添加到 FormData 中
        fd.append("avatar", filess[0])

        var xhr = new XMLHttpRequest()
        // 监听 xhr.upload 的 onprogress 事件
        xhr.upload.onprogress = function (e) {
            // e.lengthComputable 是一个布尔值 表示当前上传的资源是否具有可计算的长度
            if (e.lengthComputable) {
                // e.loaded 已传输的字节
                // e.total 需传输的总字节
                var percentComplete = Math.ceil((e.loaded / e.total) * 100)
                console.log(percentComplete);
            }

        }
        xhr.open("POST", 'http://www.liulongbin.top:3006/api/upload/avatar')
        xhr.send(fd)

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                var data = JSON.parse(xhr.responseText)

                if (data.status === 200) { // 上传成功
                    document.querySelector("#img").src = 'http://www.liulongbin.top:3006' + data.url

                } else { // 上传失败
                    console.log(data.message);

                }
            }


        }
    })
</script>

</html>
```

#### 1.导入需要的库

导入bootstarp 使用bootstrap里面的进度条美化一下进度效果

```html
<div class="progress" style="width: 500px; margin: 10px 15px;">
        <div class="progress-bar progress-bar-striped active" style="width: 0%" id="percent">
            0%
        </div>
    </div>
```

#### 2.监听上传进度的事件

```js
xhr.upload.onprogress = function(e) {
	if (e.lengthComputable) {
	// 1.计算出当前上传进度的百分比
	var percentComplete = Math.ceil((e.loaded / e.total) * 100)
	 $("#percent")
	 // 2.设置进度条的宽度
	 .attr("style", "width:" + percentComplete + '%')
	 // 3.显示当前的上传进度百分比
	 .html(percentComplete + '%')
                
	}
}
```

#### 3.监听上传完成的事件

最好记得在Network面板  设置一下网速 这样效果好一点

```js
xhr.upload.onload = function() {
	$("#percent").
	// 移除上传中的类样式
	.removeClass()
	// 添加上传完成的类样式
	.addClass(”progress-bar progress-bar-success”)
}
```

## 5.jQuery高级用法

### 5.1 jQuery实现文件上传

#### 1.定义UI结构

```html
// 导入 jQuery
<script src="./lib/jquery.min.js"></script>
// 文件选择框
<input type="file" id="file1" />
// 上传文件按钮
<button id="btnUpload">上传</button>
```

#### 2.验证是否选择了文件

```js
$("#btnUpload").on("click", function () {
   // 1.将jQuery 对象转化为 DOM对象 并获取选中的文件列表
   var files = $("#file1")[0].files
   // 2.判断是否选择了文件
   if (files.length <= 0) {
        return alert('请选择图片后再上传!')
   }
     })
```

#### 3.向FormData中追加文件

```js
// 向FormData 中追加文件
var fd = new FormData()
fd.append('avatar', files[0])
```

#### 4.使用jQuery发起上传文件的需求

```js
$.ajax({
   type: 'POST',
   url:'http://www.liulongbin.top:3006/api/upload/avatar',
   data: fd,
   // 不修改 contentType 属性 使用 FormData 默认的 content-Type 值
   contentType: false,
   // 不对 FormData 中的数据进行 url 编码 ，而是将 FormData 数据原样发送到服务器
   processData: false,
   success: function (res) {
        console.log(res);
       }
	})
```

### 5.2 jQuery实现loading效果

#### 1.ajaxStart(callback)

Ajax请求**开始**时，执行ajaxStart 函数。可以在ajaxStart的callback中显示loading效果，示例代码如下:

```js
//自 Query 版本1.8 起，该方法只能被附加到文档
$(document).ajaxStart(function() {
	$("#loading").show()
})
```

注意: $(document).ajaxStart() 函数会监听当前文档内所有的Ajax请求。

#### 2.ajaxStop(callback)

Ajax请求**结束**时，执行ajaxStop 函数。可以在ajaxStopt的callback中隐藏loading效果，示例代码如下:

```js
//自 Query 版本1.8 起，该方法只能被附加到文档
$(document).ajaxStop(function() {
	$("#loading").hide()
})
```



#### 3.综合

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./js/jQuery.min.js"></script>
    <title>Document</title>
</head>

<body>
    <input type="file" id="file1">
    <button id="btnUpload">上传</button>
    <br />
    <img src="./images/loading.gif" alt="" style="width: 100px; display: none" id="loading" />

    <script>
        $(function () {
            // 监听到ajax请求被发起了
            $(document).ajaxStart(function () {
                $("#loading").show();
            })
            // 监听到ajax完成的事件
            $(document).ajaxStop(function () {
                $("#loading").hide();

            })
            $("#btnUpload").on("click", function () {
                // 1.将jQuery 对象转化为 DOM对象 并获取选中的文件列表
                var files = $("#file1")[0].files
                // 2.判断是否选择了文件
                if (files.length <= 0) {
                    return alert('请选择图片后再上传!')
                }

                var fd = new FormData()
                fd.append('avatar', files[0])

                $.ajax({
                    type: 'POST',
                    url: 'http://www.liulongbin.top:3006/api/upload/avatar',
                    data: fd,
                    // 不修改 contentType 属性 使用 FormData 默认的 content-Type 值
                    contentType: false,
                    // 不对 FormData 中的数据进行 url 编码 ，而是将 FormData 数据原样发送到服务器
                    processData: false,
                    success: function (res) {
                        console.log(res);


                    }
                })


            })
        })
    </script>
</body>

</html>
```

## 6.axios

### 6.1 什么是axios

Axios是专注于**网络数据请求**的库。

相比于原生的XMLHttpRequest对象，axios 简单易用。

相比于jQuery, axios 更加**轻量化**，只专注于网络数据请求。

### 6.2 axios发起GET请求

要先导入axios.min.js这个包

axios发起get请求的语法:

```js
axios.get('url', {parames: { /* 参数 */} }).then(callback)
```

具体的代码示例如下：

```js
// 请求的URL地址
var url = 'http://www.liulongbin.top:3006/api/get'
// 请求的参数对象
var paramsObj = {name: 'zs', age: 18}
// 调用axios.get() 发起 GET 请求
axios.get(url, {parame: paramsobj}).then(function(res) {
    // res不是服务器返回的真实数据 因为res 是axios包装的一个对象
	// res.data 是服务器返回的数据
	var result = res.data
	console.log(result)
})
```

### 6.3 axios发起POST请求

axios发起POST请求的语法：

```js
axios.post('url', { /* 参数 */}).then(callback)
```

具体的代码示例如下：

```js
// 请求的URL地址
var url = 'http://www.liulongbin.top:3006/api/post'
// 要提交到服务器的数据
var dataObj = {location: '北京', address: '顺义区'}
// 调用  axios.post() 发起GET 请求
axios.post(url, dataObj).then(function(res) {
	// res.data 是服务器返回的数据
	var result = res.data
	console.log(result)
})
```

### 6.4 直接使用axios发起请求

axios也提供了类似于jQuery中$.ajax()的函数，语法如下：

```js
axios({
	type: '请求类型',
	url: '请求的URL地址',
    // 请求类型为 POST 时 
	data: {/* POST数据 */},、
    // 请求类型为 GET 时
	params: { /* GET数据 */}
}).then(callback)
```

#### 1.直接使用axios发起GET请求

```js
axios({
	method: 'GET',
	url: 'http://www.liulongbin.top:3006/api/get',
	params: {name: 'zs', age: 18}
}).then(function(res) {
	consloe.log(res.data)
})
```

#### 2.直接使用axios发起POST请求

```js
axios({
	method: 'POST',
	url: 'http://www/liulongbin.top:3006/api/post',
	data: {bookname: '水浒传', author: '施耐庵'}
}).then(function(res) {
	console.log(res.data)
})
```

# 四、跨域和JSONP1.了解同源策略和跨域

## 1.了解同源和跨域

### 1.1同源策略

#### 1.什么是同源

如果两个页面的**协议，域名**和**端口**都相同，则两个页面具有**相同的源**。
例如，下表给出了相对于http://www.test.com/index.html页面的同源检测:

http是协议，www.test.com是 域名 后面没跟 :数字 默认端口号是80

| URL                                | 是否同源 | 原因                                  |
| ---------------------------------- | -------- | ------------------------------------- |
| http://www.test.com/other.html     | 是       | 同源(协议、域名、端口相同)            |
| https://www.test.com/about.html    | 否       | 协议不同(http与https)                 |
| http://blog.test.com/movie.html    | 否       | 域名不同(www.test.com与blog.test.com) |
| http://www.test.com:7001/home.html | 否       | 端口不同(默认的80端口与7001端口)      |
| http://www.test.com:80/main.html   | 是       | 同源(协议、域名、端口相同)            |

#### 2.什么是同源策略

**同源策略**(英文全称Same origin policy) 是**浏览器**提供的一个**安全功能**。

MDN官方给定的概念: 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。 这是一个用于隔离潜在恶意文件的重要安全机制。

通俗的理解: 浏览器规定, A网站的JavaScript,不允许和非同源的网站C之间，进行资源的交互,例如:

① 无法读取非同源网页的Cookie、LocalStorage 和IndexedDB

② 无法接触非同源网页的DOM

③ 无法向非同源地址发送Ajax请求

### 1.2 什么是跨域

#### 1.跨域

同源指的是两个URL的协议、域名、端口-致，反之，则是**跨域**。

出现跨域的根本原因: 浏览器的同源策略不允许非同源的URL之间进行资源的交互。
网页: http://www.test.com/index.html 

接口: http://www.api.com/userlist

#### 2.浏览器对跨域请求的拦截

![image-20220530135914180](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220530135914180.png)

注意: 浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截,无法被页面获取到!

#### 3.如何实现跨域数据请求

现如今,实现跨域数据请求,最主要的两种解决方案,分别是**JSONP**和**CORS**.

JSONP: 出现的早，兼容性好(兼容低版本IE)。是前端程序员为了解决跨域问题,被迫想出来的一种临时解决方案。缺点是**只支持GET请求**,不支持POST请求。

CORS: 出现的较晚，它是W3C标准,属于跨域Ajax请求的根本解决方案。支持GET和POST请求。缺点是不兼容某些低版本的浏览器。

## 2.JSONP

### 2.1 什么是JSONP

JSONP (JSON with Padding)是JSON的一种”使用模式”， 可用于解决主流浏览器的跨域数访问的问题。

### 2.2 JSONP

由于**浏览器同源策略**的限制，网页中无法通过Ajax请求非同源的接口数据。但是<script>标签不受浏览器同源策略的影响，可以通过srC属性,请求非同源的js脚本。

因此，JSONP的实现原理，就是通过<script> 标签的src属性,请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。

### 2.3 发起跨域的ajax请求

```js
 $.ajax({
            method: 'GET',
            url: 'http://ajx.frontend.itheima.net:3006/api/josnp',
            data: {
                name: 'zs',
                aga: 18
            },
            success: function (res) {
                console.log(res);
            }
        })
// 因为网页地址 与请求的网页 不是同源的 属于跨域
// 所以请求会失败 拿不到数据
```

### 2.4 自己实现一个简单的JSONP

同一个页面另一个script里面调用： 

```html
<script>
        function success(data) {
            console.log('拿到了Data数据:');
            console.log(data);
        }
    </script>
    <!-- 在页面中 不论你定义了多少个<script>标签 里面的代码是共享的 -->
    <script>
        success({ name: 'zs', age: 18 })
    </script>
```

#### 1.JSONP的实现原理

第一步：定义一个回调函数

第二步：我们要通过script标签的src属性来请求一个接口，希望返回一个函数的调用，通过查询字符串的形式告诉服务器需要调用的函数 (callback=getdata 值就是函数的名字) 

第三步：服务器返回一个对应的函数调用

#### 2.自己实现一个简单的JSONP

定义一个success回调函数：

```html
<script>
	function success(data) {
        console.log('获取到了data数据: ')
        console.log(data)
    }
</script>
```

通过<script> 标签，请求接口数据：

```html
<script src="http://www.ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>
```

在XML页签里面没有看到ajax请求，说明JSONP不属于ajax请求

![image-20220531173234778](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220531173234778.png)

但是可以在All页签里面看到请求信息。

### 2.5 JSONP的缺点

由于JSONP是通过<script> 标签的src属性,来实现跨域数据获取的，所以, JSONP支持GET数据请求,不支持POST请求。

注意: **JSONP和Ajax之间没有任何关系**，不能把JSONP请求数据的方式叫做Ajax,因为JSONP没有用到XMLHttpRequest这个对象。

### 2.6 jQuery中的JSONP

jQuery提供的$.ajax() 函数,除了可以发起真正的Ajax数据请求之外,还能够发起JSONP数据请求，例如:

```js
$.ajax({
	url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
	//如果要使用$.ajax() 发起JSONP 请求，必须指定datatype 为jsonp 代表我们要发起JSONP的数据请求
	dataType: 'jsonp',
	success: function(res) {
		console.log (res)
}
)}
```

默认情况下，使用jQuery发起JSONP请求，会自动携带一个callback=jQueryxxx的参数, jQueryxx 是随机生成的一个回调函数名称。

### 2.7 自定义参数及回调函数名称

在使用jQuery发起JSONP请求时，如果想要自定义JSONP的参数以及回调函数名称，可以通过如下两个参数来指定:

```js
$.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    dataType: 'jsonp',
    // 发送到服务端的参数名称，默认值为 callback
    jsonp: 'callback',
    // 自定义的回调函数名称，默认值为jQueryxxx格式
    jsonpCallback: 'abc',
    success: function(res) {
        console.log(res)
    }
})
```

### 2.8 jQuery中JSONP的实现过程

jQuery中的JSONP,也是通过<script>标签的src属性实现跨域数据访问的,只不过, jQuery 采用的是动态创建和移除<script>标签的方式，来发起JSONP数据请求。

- 在发起JSONP请求的时候,动态向<header>中append -个<script> 标签;
- 在JSONP请求成功以后,动态从<header>中移除刚才append进去的<script> 标签;

## 3.案列 - 淘宝搜索

### 3.1 ui结构

![image-20220608213213477](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220608213213477.png)

### 3.2 获取用户输入的搜索关键词

为了获取到用户每次按下键盘输入的内容,需要监听输入框的keyup事件,示例代码如下: 

```js
// 监听文本框的 keyup事件
$('#ipt').on('keyup', function() {
//获取用户输入的内容
	var keywords = $(this).val().trim()
//判断用户输入的内容是否为空
	if (keywords.length <= 0) {
	return
}
    
// TODO: 获取搜索建议列表
})

```

### 3.3 封装getSuggList函数

将获取搜索建议列表的代码，封装到getSuggestList函数中，示例代码如下:

```js
function getSuggestList (kw) {
	$.ajax({
	//指定请求的URL地址，其中，q是用户输入的关键字
	url: 'https://suggest.taobao.com/sug?q=' + kw,
	//指定要发起的是JSONP请求
	dataType: 'jsonp',
	//成功的回调函数
	success: function(res) { console.log(res) }
	})
}
```

### 3.4 渲染建议列表的UI结构

#### 1.定义搜索建议列表

```html
<div class="box">
	<!-- tab栏区域-->
	<div class="tabs"></div>
	<!--搜索区域-->
	<div class= "search-box"></div>
	<!--搜索建议列表-->
	<div id="suggest-list"> </div>
</div>

```

#### 2.定义模板结构

```html
<!--模板结构-->
<script type="text/html" id="tpl-suggestList">
	{{each result}}
		<div class="suggest-item">{ {$value[0]} }</div>
	{{/each}}
</script>
```

#### 3.定义渲染模板结构的函数

```js
//渲染建议列表
function renderSuggestList(res) {
	//如果没有需要渲染的数据，则直接: return
	if (res.result.length <= 0) {
		return $('#suggest-list').empty().hide()
    }
	//渲染模板结构
	var htmlStr = template('tpl-suggestList', res)
	$('#suggest-list').html(htmlStr).show()
}
```

#### 4.搜索关键词为空时隐藏搜索建议列表

```js
$('#ipt') .on('keyup', function() {
	//获取用户输入的内容
	var keywords = $(this).val().trim()
	//判断用户输入的内容是否为空
	if (keywords.length <= 0) {
	//如果关键词为空，则清空后隐藏搜索建议列表
	return $ ('#suggest-list').empty().hide()
	getSuggestList(keywords)
})

```

### 3.5 输入框的防抖

#### 1.什么是防抖

防抖策略(debounce) 是当事件被触发后，**延迟n秒**后**再执行回调**，如果在这n秒内事件又被触发，则重新计时。

![image-20220609150449254](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220609150449254.png)

防抖的好处就是 事件被频繁触发的时候，保证事件只被执行一次，不会被频繁的执行

#### 2.防抖的应用场景

用户在输入框中连续输入一串字符时，可以通过防抖策略,只在输入完后,才执行查询的请求，这样可以有效减少请求次数，节约请求资源;

#### 3.实现输入框的防抖

```js
var timer = null;        				//1.防抖动的timer
function debounceSearch(keywords) {		//2.定义防抖的函数
    timer = setTimeout(function() {
        //发起JSONP请求
        getSuggestList(keywords)
    }, 500)
}

$("#ipt").on("keyup", function() {//3.在触发 keyup 事件时 立即清空 timer
    // ...省略其他代码
    debounceSearch(keywords)
})
```

### 3.6 缓存搜索的建议列表

#### 1.定义全局缓存对象

```js
// 缓存对象
var cacheObj = {}
```

#### 2.将搜索结果保存到缓存对象中

```js
	//渲染建议列表
	function renderSuggestList(res) {
	// ...省略其他代码
        
	//将搜索的结果，添加到缓存对象中
	var k = $('#ipt').val().trim()
	cacheObj [k] = res
    }
```

#### 3.优先从缓存中获取搜索建议

```js
	//监听文本框的keyup事件
	$('#ipt').on('keyup', function() {
	// ... 省略其他代码
        
        
	//优先从缓存中获取搜索建议
	if (cache0bj[keywords]) {
	return renderSuggestList(cacheObj[keywords])
	//获取搜索建议列表
	debounceSearch(keywords)
})
```

## 4.防抖和节流

### 4.1 什么是节流

节流策略(throttle), 顾名思义，可以减少一段时间内事件的触发频率。

![image-20220611144524347](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220611144524347.png)

### 4.2 节流的应用场景

1. 鼠标连续不断地触发某事件(如点击)，只在单位时间内只触发一次;
2. 懒加载时要监听计算滚动条的位置，但不必每次滑动都触发,可以降低计算的频率，而不必去浪费CPU资源;

### 4.3 节流案列 - 鼠标跟随效果

#### 1.渲染UI结构并美化样式

```html
<!-- UI结构 -->
<img src="./assets/angel.gif" alt="" id="angel" />
/*CSS样式*/
html, body {
	margin: 0;
	padding: 0;
	overflow: hidden;
}
#angel {
	position: absolute;
}
```

#### 2.不使用节流时实现鼠标跟随效果

```js
$(function() {
	//获取图片元素
	var angel = $('#angel')
	//监听文档的mousemove 事件
	$(document).on( 'mousemove', function(e) {
	//设置图片的位置
	$ (ange1).css('left', e.pagex + 'px').css('top', e.pageY + 'px')
	})
})

```

#### 3.节流阀的概念

节流阀为**空**，表示可以**执行下次操作**; **不为空**，表示**不能执行下次操作**。

当前操作执行完，必须将节流阀**重置**为空，表示可以执行下次操作了。

每次执行操作前，必须**先判断节流阀是否为空**。

#### 4.使用节流优化鼠标跟随效果

```js
$(function() {
	var angel = $('#angel')
	var timer = null // 1. 预定义一个timer 节流阀
	$(document).on ( ' mousemove'，function(e){
	if(timer) { return } // 3. 判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒
	timer = setTimeout (function() {
		$ (angel) .css('left', e.pageX + 'px') .css('top', e.pageY + 'px')
	timer = null // 2. 当设置了鼠标跟随效果后，清空timer节流阀，方便下次开启延时器
	}，16)
  })
})

```

### 4.4 防抖和节流的区别

- 防抖:如果事件被频繁触发，防抖能保证只有最有一次触发生效! 前面N多次的触发都会被忽略!
- 节流:如果事件被频繁触发,节流能够减少事件触发的频率，因此，节流是有选择性地执行部分事件!