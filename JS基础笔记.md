# 1.编程语言

## 1.1编程

**编程**：就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。

**计算机程序**：就是计算机所执行的一系列的**指令集合**，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命名。

**注意**：上面所定义的计算机指的是**任何能够执行代码的设备**，可能是智能手机、ATM机、黑莓PI、服务器等等。

## 1.2 计算机语言

**计算机语言**指用于**人与计算机之间通讯的语言**，它是人与计算机之间传递信息的**媒介**。

计算机语言的种类非常多，总的来说可以分成**机器语言，汇编语言和高级语言**三大类。

实际上计算机最终所执行的都是**机器语言**，它是由“0”和“1”组成的二进制数，**二进制是计算机语言的基础。**

![image-20220119173401280](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119173401280.png)

## 1.3编程语言

可以通过类似于人类语言的“语言”来控制计算机，让计算机为我们做事情，这样的语言叫做编程语言（Programming Language）。

编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。

如今通用的编程语言有两种形式：**汇编语言**和**高级语言。**

**●汇编语言**和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。

**●高级语言**主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、JavaScript、Go语言、Objective-C、Swift等。

![image-20220119173637910](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119173637910.png)

## 1.4 翻译器

高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。

翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。记住1和0.

![image-20220119174103004](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119174103004.png)

## 1.5 编程语言和标记语言区别

●编程语言有很强的逻辑和行为能力。在编程语言里，你会看到很多if else、for、while等具有逻辑性和行为能力的指令，这是主动的。

●标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的，他是被动的。

 

### **总结**

\1. 计算机可以帮助人类解决某些问题

\2. 程序员利用编程语言编写程序发出指令控制计算机来实现这些任务

\3. 编程语言有机器语言、汇编语言、高级语言

\4. 高级语言需要一个翻译器转换为计算机识别的机器语言

\5. 编程语言是主动的有很强的逻辑性

# 2.计算机基础

## 2.1 计算机组成

![image-20220119181158729](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119181158729.png)

## 2.2 数据存储

1.计算机内部使用二进制0和1来表示数据

2.所有数据，包括文件，图片等最终都是以二进制数据（0和1）的形式存放在硬盘中的

3.所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中，平时我们所说的安装软件，其实就是把程序文件复制到硬盘中。

4.硬盘，内存都是保存的二进制数据。

## 2.3 数据存储单位

●bit<byte<kb<GB<TB<…

●位（bit）：1bit可以保存一个0或者1（最小的存储单位）

●字节（Byte）：1B = 8b

●千字节（KB）：1KB = 1024B

●兆字节（MB）：1MB = 1024KB

●吉字节（GB）：1GB = 1024MB

●太字节（TB）：1TB = 1024GB

**●**…

## 2.4 程序运行

![image-20220119181426617](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119181426617.png)

1.打开某个程序时，先从硬盘中把程序的代码加载到内存中

2.CPU执行内存中的代码

注意;之所以要内存的一个重要原因，是因为cpu运行太快了，如果只从硬盘中读取数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据（内存是电，硬盘是机械）

# 1.初始JavaScript

## 1.1 JavaScript历史

![image-20220119181529266](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119181529266.png)

## 1.2 JavaScript是什么

●JavaScript是世界上最流行的语言之一，是一种运行在客户端的脚本语言（Script是脚本的意思）

●脚本语言：不需要编译，运行过程中由Js解释器（js引擎）逐行来进行解释并执行

●现在也可以基于Node.js技术进行服务器端编程

![image-20220119181752277](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119181752277.png)

**为了阅读方面，我们后面把JavaScript简称为JS。**

## 1.3 JavaScript的作用

●表单动态校验（密码强度检测）（JS产生最初的目的）

●网页特效

●服务端开发（Node.js）

●桌面程序（Electron）

●App（Cordova）

●控制硬件 物联网（Ruff）

●游戏开发（cocos2d-js）

## 1.4  HTML/CSS/JS的关系

HTML/CSS标记语言—描述类语言

●HTML决定网页结构和内容（决定看到什么），相当于人的身体

●CSS决定网页呈现给用户的模样（决定好不好看），相当于给人穿衣服、打扮

JS脚本语言—编程类语言

●实现业务逻辑和页面控制（决定功能），相当于人的各种动作

## 1.5 浏览器执行JS简介

浏览器分成两部分：渲染引擎和JS引擎

**渲染引擎**：用来解析HTML与CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit

**JS引擎**：也称为JS解释器，用来读取网页中的JavaScript代码，对齐处理后运行，比如chrome浏览器V8

**浏览器本身并不会执行代码，而是通过内置JavaScript引擎（解释器）来执行JS代码，JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以JavaScript语言归为脚本语言，会逐行解释执行。**

![image-20220119182032659](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119182032659.png)

## 1.6 JS的组成

![image-20220119182048262](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119182048262.png)

## 1.7 JS的组成

### 1.ECMAScript

ECMAScript是由ECM国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或Jscript，但实际上后两者是ECMAScript语言的实现和扩展。

![image-20220119182205066](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119182205066.png)

ECMAScript; ECMAScript规定了JS的编程语言和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。

![image-20220119182221351](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119182221351.png)

### 2.DOM ----文档对象模型

**文档对象模型**（Document Object Model， 简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口，通过DOM提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）。

### 3.BOM ----浏览器对象模型

**浏览器对象模型**（Browser Object Model，简称BOM）是指浏览器对象模型，它提供了独立于内容的，可以与浏览器窗口进行互动的对象结构，通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

##  1.8 JS初体验

JS有3种书写位置，分别为行内、内部和外部

### 1.行内式JS

```html
(input type = "button" value = "点我试试" onclick = “alert（'Hello World') "/>
```

●可以将单行或少量JS代码写在HTML标签的事件属性中（以on开头的属性），如：onclick

●注意单双引号的使用：在HTML中我们推荐使用双引号，JS中我们推荐使用单引号

●可读性差，在html中编写JS大量代码时，不方便阅读

●引号易错，引号多层嵌套匹配时，非常容易弄混

●特殊情况下使用

### 2.内嵌式JS

```
<script type="text/javascript">
	alert('Hello World');
</script>
```

普通script标签，如果没有指定type，默认的type类型为text/javascript，表示我们希望将script里面的所有代码都当做js去解析，去执行。

●可以将多行JS代码写到*<script>*标签中

●内嵌JS是学习时常用的方式

### 3.外部JS文件

```javascript
<script src = "my.js"></script>
```

●利用HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观、也方便文件级别的复用

●饮用外部js文件的script标签中间不可以写代码

●适合于JS代码量比较大的情况

## 2.JavaScript注释

单行注释 ctrl + /  多行注释 shift+ctrl+a

# 3.JavaScript输入输出语句

为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：

| 方法               | 说明                           | 归属   |
| :----------------- | ------------------------------ | ------ |
| alert（msg）       | 浏览器弹出警示框               | 浏览器 |
| console.log（msg） | 浏览器控制台打印输出信息       | 浏览器 |
| prompt（info）     | 浏览器弹出输入框，用户可以输入 | 浏览器 |

![image-20220119183243686](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119183243686.png)

# 4.变量概述

## 4.1什么是变量

白话：变量就是一个装东西的盒子。

通俗：变量是用于存放数据的**容器**。我们通过**变量名**获取数据，甚至数据可以修改。

## 4.2变量在内存中的存储

本质;变量是程序在内存中申请的一块用来存放数据的空间。

类似我们酒店的房间，一个房间就可以看做是一个变量。

![image-20220119183404521](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119183404521.png)

# 5.变量的使用

变量在使用时分为两步：1.声明变量 2.赋值

## 5.1声明变量

```javascript
// 声明变量
var age; // 声明一个名称为age的变量
```

●var是一个JS关键字，用来声明变量（variable变量的意思），使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管

●age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间

## 5.2赋值

```javascript
age = 10; // 给age这个变量赋值为10
```

● = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思

●变量值是程序员保存到变量空间里的值

##  5.3变量的初始化

```
var age = 18; // 声明变量同时赋值为18
```

![image-20220119183715428](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119183715428.png)

## 5.4变量语法扩展

### 1.更新变量

一个变量被重新赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。

### 2.同时声明多个变量

同时声明多个变量时（集体声明），只需要写一个var，多个变量名之间使用英文逗号隔开。

### 3.声明变量特殊情况

| 情况                          | 说明                   | 结果      |
| ----------------------------- | ---------------------- | --------- |
| var  age；  console.log(age); | 只声明 不赋值          | undefined |
| console.log(age)              | 不声明 不赋值 直接使用 | 报错      |
| age  = 10;  console.log(age); | 不声明 只赋值          | 10        |

## 5.5 变量命名规范

●由字母（A-Za-z）、数字（0-9）、下划线（_）、美元符号（$）组成，如：usrAge，num01，_name

●严格区分大小写，var app；和var APP；是两个变量

●不能以数字开头，18age 是错误的

●不能是关键字、保留字。例如：var、for、while

●变量名必须有意义，MMD BBD nl à age

●遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName

●推荐翻译网站：有道 爱词霸

 **案列**：交换两个变量的值（实现思路：使用一个临时变量用来做中间存储）

![image-20220119211826298](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119211826298.png)![image-20220119211837297](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119211837297.png)

# 6.小结

## **1** **为什么需要变量？**

●因为我们一些数据需要保存，所以需要变量

## **2** **变量是什么？**

●变量就是一个容器，用来存放数据的。方便我们以后使用里面的数据。

●变量是内存里的一块空间，用来存储数据。

## **3** **变量的本质是什么？**

●什么变量本质是去内存申请空间。

## **4** **变量怎么使用的？**

●我们使用变量的时候，一定要声明变量，然后赋值

## **5** **什么是变量的初始化？**

●声明变量并赋值我们称之为变量的初始化

## **6** **变量命名规范有哪些?**

●变量名尽量要规范，见名知意---驼峰命名法

●区分哪些变量名不合法

## **7** **交换2个变量值的思路？**

●学会交换2个变量

# 1.数据线简介

## **1** .1**为什么需要数据类型**

在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。

简单来说，数据类型就是数据的类别型号，比如姓名“张三”，年龄18，这些数据的类型是不一样的。

## **2.1**变量的数据类型

变量是用来存储值的所在处，它们有名字和数据类型，变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。**JavaScript是一种弱类型或者说动态语言**。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。

```
var age = 10; // 这是一个数字型
var areYoukOk = '是的'; // 这是一个字符串
```

在代码运行时，变量的数据类型是由JS引擎**根据 = 右边变量值的数据类型来判断的**，运行完毕之后，变量就确定了数据类型。

**JavaScript拥有动态类型，同时也意味着相同的变量可用作不同的类型；**

```javascript
var x = 6; // x为数字
var x = 'Bill'; // x为字符串
```

**简言之意**：js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的

Js是动态语言 变量的数据类型是可以变化的

## 1.3 数据类型的分类·

JS把数据类型分为两类：

●简单数据类型（Number，String，Boolean，Undefined，Null）

●复杂数据类型（object）

# 2.简单数据类型

## **2.1** **简单数据类型（基本数据类型）**

JavaScripe中的简单数据类型及其说明如下：

| 简单数据类型 | 说明                                               | 默认值    |
| ------------ | :------------------------------------------------- | --------- |
| Number       | 数字型，包含 整型值和浮点型值，如21、0.21          | 0         |
| Boolean      | 布尔值类型，如true、false，等价于1和0              | false     |
| String       | 字符串类型，如“张三”注意咱们js里面，字符串都带引号 | “”        |
| Undefined    | var  a；声明了变量a但是没有给值，此时a = undefined | undefined |
| Null         | var  a = null；声明了变量a为空值                   | null      |

## 2.2 数字型Number

```javascript
JavaScript数字类型既可以用来保存整数值，也可以保存小数（浮点数）
var age = 21; //整数
var age = 21.3747; //小数

```

### 1.数字型进制

最常见的进制有二进制、八进制、十进制、十六进制。

```javascript
//1.八进制数字序列范围：0-7
var num1 = 07； //对应十进制的7
var num1 = 019；//对应十进制的19
var num1 = 08； //对应十进制的8
//2.十六进制数字序列范围：0-9以及a~f
var num1 = 0xa；//对应十进制的10

```

现阶段我们只需要记住，**在JS中八进制前面加0，十六进制前面加0x**

### 2.数字型范围

JavaScript中数值的最大和最小值

```javascript
alert(Number.MAX_VALUE); //1.7976931348623157e+308
alert(Number.MIN_VALUE); //5e-32

```

●最大值：Number.MAX_VALUE，这个值为：1.7976931348623157e+308

●最小值：Number.MIN_VALUE，这个值为：5e-32

### 3.数字型三个特殊值

```javascript
alert(Infinity); // Infinity
alert(-Infinity);// - Infinity
alert(NaN);	   // NaN

```

●Infinity,代表无穷大，大于任何数值

●-Infinity，代表无穷小，小于任何数值

●NaN，Not a number，代表一个非数值

![image-20220119213421277](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119213421277.png)

### 4.isNaN()

用来判断一个变量是否为非数字的类型，返回true或者false

![image-20220119213459397](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119213459397.png)

![image-20220119213507355](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119213507355.png)

## 2.3字符串型String

字符串型可以是引号中的任意文本，其语法为双引号””和单引号’’

```javascript
var strMsg = “我爱北京天安门~”;// 使用双引号表示字符串
var strMsg2 = ‘我爱吃猪蹄~’; // 使用单引号表示字符串
//常见错误
vsr strMsg3 = 我爱大肘子; // 报错，没使用引号，会被认为是js代码，但js没有这些语法

```

因为HTML标签里面的属性使用的是双引号，JS这里我们**更推荐使用单引号。**

### 1.字符串引号嵌套

JS可以用**单引号嵌套双引号，**或者用**双引号嵌套单引号（外双内单，外单内双）**

```javascript
var strMsg = ‘我是“高富帅”程序猿’；//可以用‘’包含””
var strMsg2 = “我是‘高帅富’程序猿”；//也可以用““包含‘’
//常见错误
var badQuotes = ‘What on earth？”；//报错，不能单双引号搭配 

```

### 2.字符串转义符

类似HTML里面的特殊字符，字符串也有特殊字符，我们称之为转义符。

转义符都是\开头的，常用的转义符及其说明如下：

| **转义符** | 解释说明                 |
| ---------- | ------------------------ |
| \n         | 换行符，n是newline的意思 |
| \\         | 斜杠\                    |
| \’         | ‘单引号                  |
| \”         | “双引号                  |
| \t         | tab  缩进                |
| \b         | 空格，b是blank的意思     |

### 3.字符串长度

字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的length属性可以获取整个字符串的长度。

```javascript
var strMsg = “My name is Tom!”;
alert(strMsg.length);//显示15

```

### 4.字符串拼接

●多个字符串之间可以使用 + 进行拼接，其拼接方式为字符串 + 任何类型 = 拼接之后的新字符串

●拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串。

```javascript
//1.字符串“相加”
consle.log (‘hello’+’’+’world’);//hello world
//2.数值字符串“相加”
consle.log(‘100’ + ‘100’);//100100
//3.数值字符串 + 数值
 consle.log(‘11’+12);//1112

```

**\+ 号总结口诀：数值相加，字符相连**

### 5.字符串拼接加强

●我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值

●变量是不能添加引号的，因为加引号的变量会变成字符串

●如果变量两侧都有字符串拼接，口诀“引引加加”，删掉数字，变量写在两个加中间

```javascript
	consle.log（'pink老师’+ 18）；//只要有字符就会相连
	var age = 18；
	// consle.log（'pink老师age岁啦’）； //这样是错的
	consle.log（’pink老师’+ age）；//pink老师18
	consle.log（’pink老师’ + age + ‘岁啦’）；//pink老师18岁啦

```

## 2.4 布尔型Boolean

布尔型有两个值：true和flase，其中true表示真（对），而flase表示假（错）。

布尔型和数字型相加的时候，true的值为1，false的值为0.

```javascript
consle.log（true + 1）；//2
consle.log（flase + 1）；//1

```

## 2.5 underfined和null

一个声明后没有被赋值的变量会有一个默认值undefined（如果进行相连或者相加时，注意结果）

```javascript
//如果一个变量声明未赋值 就是 undefined 未定义数据类型
var variable；
consle.log（variable）；// undefied
consle.log（‘你好’+ variable）；// 你好undefined
consle.log（11 + variable）；// NaN
consle.log(true + variable); // NaN

```

一个声明变量给null值，里面存的值为空（学习对象时，我们继续研究null）

```javascript
var vari = null；
consle.log（‘你好’+ vari）；//你好null
consle.log（11 + vari）；//11
consle.log(true + vari); //1

```

# 3.获取变量数据类型

## 3.1 获取检测变量的数据类型

typeof可用来获取检测变量的数据类型

![image-20220119215456494](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119215456494.png)

## 3.2 字面量

字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。

数字字面量：8,9,10

字符串字面量：‘黑马程序员’，‘大前端’

布尔字面量：true，flase

通过控制台的颜色属于哪种数据类型。

# 4.数据类型转换

## 4.1 什么是数据类型转换

使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型，通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。

我们通常会实现3种方式的转换；

●转换为字符串类型

●转换为数字型

●转换为布尔型

## 4.2 转换为字符串

| **方式**           | **说明**                     | **案列**                               |
| ------------------ | ---------------------------- | -------------------------------------- |
| ToString           | 转成字符串                   | var  num=1；  alert（num.toString()）; |
| String（）强制转换 | 转成字符串                   | var  num=1；  alert(String(num));      |
| **加号拼接字符串** | 和字符串拼接的结果都是字符串 | var  num=1；  alert(num+’我是字符串’); |

●toString（）和String（）使用方式不一样。

●三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一种方式也称之为隐式转换。

## 4.3 转换为数字型（重点)

| 方式                    | 说明                       | 案列                                      |
| ----------------------- | -------------------------- | ----------------------------------------- |
| parseInt(string)函数    | 将string类型转成整数数值型 | parseInt（变量）  parseInt（‘78’）        |
| parseFloat(string）函数 | 将string类型转成整数数值型 | parseFloat（变量）  parseFloat（‘78.21’） |
| Number（）强制转换函数  | 将string类型转成整数数值型 | Number（变量）  Number(‘12’)              |
| Js隐式转换（- * /）     | 将string类型转成整数数值型 | ‘12’-0                                    |

●注意parseInt和parseFloat单词的大小写，这2个是重点

●parseInt可以把字符型的转换为数字型 得到的是整数。

●parseFloat可以把字符型的转换为数字型 得到的是小数 浮点数

●隐式转换是我们在进行算数运算的时候，Js自动转换了数据类型。

## 4.4 转换为布尔型

| **方式**      | **说明**           | **案列**        |
| ------------- | ------------------ | --------------- |
| Boolean()函数 | 其他类型转成布尔值 | Boolean(‘true’) |

●代表空、否定的值会被转换为false，如“”、0、NaN、null、underfined

●其余值都会被转换为true

```javascript
console.log(Boolean(‘’))；//false
console.log(Boolean(0))；//false
console.log(Boolean(NaN))；//false
console.log(Boolean(null))；//false
console.log(Boolean(underfined))；//false
console.log(Boolean(‘小白’))；//true
console.log(Boolean(null))；//true

```

# 1.解释型语言和编译型语言

## 1.1 概述

计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序，程序语言翻译成机器语言的工具，被称为翻译器。

![image-20220119220056183](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119220056183.png)

●翻译器翻译的方式有两种：一个是编译，另一个是解释。两种方式之间的区别再与翻译的时间点不同

●编译器是在代码执行之前进行编译，生成中间代码文件

●解释器是在运行时进行及时解释，并立即执行（当翻译器以解释方式运行的时候，也被称之为解释器）

## 1.2 执行过程

![image-20220119220125758](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119220125758.png)

# 2.标识符、关键字、保留字

## 2.1 标识符

标识符：就是指开发人员为变量、属性、函数、参数取的名字。

**标识符不能是关键字或保留字**

## 2.2 关键字

关键字：是指JS本身已经使用了的字，不能再用它们充当变量名、方法名。

包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with等。

## 2.3 保留字

保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。

包括：boolean、byte、char、class、constant、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、inteerface、long、mative、package、private、protected、public、short、static、super、synchronized、throw、transient、volatile等。

# 1.运算符

运算符（operator）也被称为**操作符**，是用于实现赋值，比较和执行算数运算等功能的符号。

JavaScript中常用的运算符有：

●算数运算符

●递增和递减运算符

●比较运算符

●逻辑运算符

●赋值运算符

# 2.算数运算符

## 2.1 算数运算符概述

概念;算术运算使用的符号，用于执行两个变量或值的算术运算。

| 运算符 | 描述           | 实例                    |
| ------ | -------------- | ----------------------- |
| +      | 加             | 10  + 2 = 12            |
| -      | 减             | 10  – 2 = 8             |
| *      | 乘             | 10  * 2 = 20            |
| /      | 除             | 10  / 2 = 5             |
| %      | 取余数（取模） | 返回除法的余数9 % 2 = 1 |

## 2.2 浮点数的精度问题

浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。

```javascript
var result = 0.1 + 0.2；  //结果不是0.3，而是：0.30000000000000004
consle.log(0.07 * 100)；  //结果不是7，而是：7.00000000000000001

```

## 2.3 小总结

判断一个数能够被整除：它的余数是0 就说明这个数能被整除，这就是%取余运算符的主要用途

1 + 2 * 3的结果是7：注意算术运算符优先级，先乘除，后加减，有小括号先算小括号里面的

## 2.4 表达式和返回值

表达式:是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合

简单理解：是由数字、运算符、变量等组成的式子。

# 3.递增和递减运算符

## 3.1 递增和递减运算符概述

如果需要反复给数字变量添加或减去1，可以是由**递增（++）**和**递减（--）**运算符来完成。

在JavaScript中，递增（++）和递减（--）既可以放在变量前面，也可以放在变量后面。**放在变量前面**时，我们可以称为**前置递增（递减）运算符，放在变量后面**时，我们可以称为**后置递增（递减）运算符。**

**注意：递增和递减运算符必须和变量配合使用。**

****

## 3.2 递增运算符

### 1.前置递增运算符

++num前置递增，就是自加1，类似于num = num + 1，但是++num写起来更简单。

### 2.后置递增运算符

num++后置递增，就是自加1，类似于num = num + 1,但是num++写起来更简单。

使用口诀; 先返回原值，后自加

![image-20220119220834830](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119220834830.png)

## 3.3 前置递增和后置递增小结

●前置递增和后置递增运算符可以简化代码的编写，让变量的值+1 比以前写法更简单

●单独使用时，运算结果相同

●与其他代码连用时，执行结果会不同

●后置：先原值运算，后自加（先人后己）

●前置：先自加，后运算（先己后人）

●开发时，大多使用后置递增/递减，并且代码独占一行，例如：num++；或者num-

# 4.比较运算符

## 4.1比较运算符概述

概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true/false）作为比较运算的结果。

| **运算符名称** | **说明**                     | **案列**     | **结果** |
| -------------- | ---------------------------- | ------------ | -------- |
| <              | 小于号                       | 1  < 2       | true     |
| >              | 大于号                       | 1  > 2       | false    |
| >=             | 大于等于号（大于或者等于）   | 2  >= 2      | true     |
| <=             | 小于等于号（小于或者等于）   | 3  <= 2      | false    |
| ==             | 判断号（会转型）             | 37  == 37    | true     |
| !=             | 不等号                       | 37  != 37    | false    |
| ===   !==      | 全等 要求值和 数据类型都一致 | 37  === ‘37’ | false    |

4.2 小结

| 符号 | 作用 | 用法                                     |
| ---- | ---- | ---------------------------------------- |
| =    | 赋值 | 把右边的值给左边                         |
| ==   | 判断 | 判断两边值是否相等（注意此时有隐式转换） |
| ===  | 全等 | 判断两边的值和数据类型是否完全相同       |

```javascript
console.log(18 == ‘18’)；//true
console.log(18 === ‘18’)；//false

```

# 5.逻辑运算符

## 5.1 逻辑运算符概述

概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值，后面开发中经常用于多个条件的判断

| **逻辑运算符** | **说明**               | **案例**         |
| -------------- | ---------------------- | ---------------- |
| &&             | “逻辑与”，简称“与” and | true  && false   |
| \|\|           | “逻辑或”，简称“或” or  | true  \|\| false |
| ！             | “逻辑非”，简称“非” not | ！true           |

| 逻辑与&&   | 两边都是true才返回true，否则返回false                        |
| ---------- | ------------------------------------------------------------ |
| 逻辑或\|\| | 两边都为false才返回false，否则都为true                       |
| 逻辑非！   | 逻辑非（！）也叫作取反符，用来取一个布尔值相反的值，如true的相反值是false |

```javascript
var isOk = !true；
console.log(isOk)；//false

```

## 5.2 短路运算（逻辑中断）

短路运算的原理：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值；

### 1. 逻辑与&&

●语法：表达式1 && 表达式2

●如果第一个表达式的值为真，则返回表达式2

●如果第一个表达式的值为假（0 ‘’ null underfined NaN 其余为真），则返回表达式1

```javascript
console.log(123 && 456)；//456
console.log(0 && 123 && 789)；//0

```

### 2. 逻辑或||

语法：**表达式1 || 表达式2**

如果第一个表达式的值为真，则返回表达式1

如果第一个表达式的值为假，则返回表达式2

```javascript
console.log(123 || 456 || 789)；//123
console.log(0 || 123 )；//123

```

```javascript
例：var num = 0；
  	console.log(123 || num++)；
	Console.log(num)；// 0 因为第一个表达式为真 直接返回表达式1 逻辑中断 num++ 就没有进行运算

```

# 6.赋值运算符

概念：用来把数据赋值给变量的运算符

| **赋值运算符** | **说明**             | **案例**                      |
| -------------- | -------------------- | ----------------------------- |
| =              | 直接赋值             | var  usrName = ‘我是值’       |
| +=、-=         | 加、减一个数后再赋值 | var  age = 10；  age+=5；//15 |
| *=、/=、%=     | 乘、除、取模后再赋值 | var  age = 2；  age*=5；//10  |

```javascript
var age = 10；
age += 5；//相当于 age = age + 5；
age -= 5；//相当于 age = age – 5；
age *= 10；//相当于age = age * 10；

```

# 7.运算符优先级

| 优先级 | 运算符     | 顺序           |
| ------ | ---------- | -------------- |
| 1      | 小括号     | （）           |
| 2      | 一元运算符 | ++  -- ！      |
| 3      | 算数运算符 | 先* / %后+-    |
| 4      | 关系运算符 | Ø >= < <=      |
| 5      | 相等运算符 | ==  != === !== |
| 6      | 逻辑运算符 | 先&& 后 \|\|   |
| 7      | 赋值运算符 | =              |
| 8      | 逗号运算符 | ,              |

●一元运算符里面的逻辑非优先级很高

●逻辑与比逻辑或优先级高

# 1.流程控制

在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的，很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。

简单理解：流程控制就是来控制我们的代码按照什么结构顺序来执行

流程控制主要有三种结构，分别是顺序结构、分支结构和循环结构，这三种结构代表三种代码执行的顺序。

![image-20220119221650089](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119221650089.png)

# 2.顺序流程控制

顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。

![image-20220119221722239](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119221722239.png)

# 3.分支流程控制if语句

## 3.1 分支结构

由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果

![image-20220119221808389](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119221808389.png)

Js语言提供了两种分支结构语句

●if语句

●switch

## 3.2 if语句

### 1.语法结构

```javascript
if （表达式）{
	// 执行语句
}

```

执行思路 如果if里面的条件表达式结果为真 true 则执行大括号里面的 执行语句   如果if 条件表达式结果为假 则不执行大括号里面的语句 则执行if 语句后面的代码

语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。

### 2.执行流程

![image-20220119222011893](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119222011893.png)

## 3.3 if else 语句（双分支语句）

### 1.语法结构

```javascript
//条件成立 执行if里面代码，否则执行else里面的代码
If （表达式）{
	//[如果]条件成立执行的代码
} else {
	//[否则]执行的代码
}

```

if里面的语句1 和 else 里面的语句2 最终只能用一个语句执行 2选1

else后面直接跟大括号

### 2. 执行流程

![image-20220119222151396](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119222151396.png)

## 3.4 if else if 语句（多分支语句）

### 1. 语法结构

多分支语句  就是利用多个条件来选择不同的语句执行  得到不同的结果  多选1 的过程

```javascript
if （条件表达式1）{
	//语句1；
} else if （条件表达式2）{
	//语句2；
} else if （条件表达式3）{
	//语句3；
} else {
	//最后的语句；
}

```

### **执行的思路：**

如果条件表达式1 满足就执行 语句1 执行完毕后，退出整个if 分支语句

如果条件表达式1 不满足，则判断条件表达式2 满足的话，执行语句2 以此类推

如果上面的所有条件都不成立，则执行else 里面的语句

### **注意点：**

（1） 多分支语句还是多选1 最后只能有一个语句执行

（2） else if 里面的条件理论上是可以任意多个的

（3） else if 中间有个空格了

### 2.执行流程

![image-20220119222406683](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119222406683.png)

# 4. 三元表达式

三元表达式也能做一些简单的条件选择。有三元运算符组成的式子称为三元表达式

## 4.1语法结构;

*条件表达式 ？表达式1 ：表达式2*

## 4.2执行思路;

如果条件表达式结果为真 则 返回 表达式1 的值 如果条件表达式结果为假 则返回 表达式2 的值

# 5. 分支流程控制switch语句

## 5.1switch语句语法结构

switch语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要**针对变量设置一系列的特定值的选项时**，就可以使用switch

switch 语句也是多分支语句 也可以实现多选1

语法结构  switch 转换、开关  case 小例子或者选项的意思

```javascript
switch（表达式）{
	case value1：
		执行语句1；
		break；
	case value2：
		执行语句2；
		break；
	…
	default：
		执行最后的语句；
}

```

### 执行思路：

利用我们的表达式的值 和 case 后面的选项值相匹配 如果匹配上，就执行该case里面的语句  如果没有匹配上，那么执行 default里面的语句

## 5.2 switch语句注意事项

1. 我们开发里面，表达式我们经常写成变量

2. 我们变量的值 和 case 里面的值相匹配的时候是 全等  必须是值和数据类型一致才可以  例num === 1

3. break 如果当前的case里面没有break 则不会退出switch 是继续执行下一个case

①一般情况下，它们两个语句可以相互替换

②switch…case 语句通常处理case为比较确定值的情况，而if…else…语句更加灵活，常用于范围判断（大于、等于某个范围）

③switch语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else语句有几种条件，就得判断多少次。

④当分支比较少时，if…else语句的执行效率比switch语句高。

⑤当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。

# 1. 循环

## 循环目的

在实际问题中，有许多具有**规律性的重复操作**，因此在程序中要完成这类操作就需要**重复执行某些语句**

# 2.for循环

在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句

## 2.1 语法结构

for循环主要用于把某些代码循环若干次，通常跟计数有关系。其语法结构如下：

```javascript
for （初始化变量；条件表达式；操作表达式）{
	//循环体
}

```

初始化变量：就是用var 声明的一个普通变量，通常用于作为计数器使用

条件表达式：就是用来决定每一次循环是否继续执行 就是终止的条件

操作表达式：是每次循环最后执行的代码经常用于我们计数器变量进行更新（递增或递减）

## 2.2 for循环的执行过程

```javascript
for (var i = 1；i <= 100；i++) {
	console.log(‘你好吗’)；
}

```

1. 首先执行里面的计数器变量 var i = 1 ，但是这句话在for 里面只执行一次 i是index的缩写

2. 去 i <= 100 来判断是否满足条件，如果满足条件 就去执行 循环体 不满足条件退出循环

3. 最后去执行 i++ i++是单独写的代码 递增 第一轮结束

4. 接着去执行 i <= 100 如果满足条件 就去执行 循环体 不满足条件退出循环 第二轮

## 2.3 断点调试

断点调试是指自己在程序的某一行设置一个断点，调试时候=，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。

**断点调试可以帮我们观察程序的运行过程**

浏览器中按F12àsourcesà找到需要调试的文件à在程序的某一行设置断点

watch监视，通过watch可以监视变量的值的变化，非常的常用。

F11：程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。

代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力，初学者不要觉得调试代码麻烦就不去调试。

## 2.4 for循环重复不同的代码

for循环还可以重复不同的代码，这主要是因为使用了计数器，计数器在每次循环过程中都会有变化。

## 2.5 for循环重复某些相同的代码

for循环因为有了计数器的存在，我们还可以重复的执行某些操作，比如做一些算术运算。

![image-20220119223134847](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119223134847.png)

```javascript
例题：一行打印五个星星
☆☆☆☆☆
代码;
var str = ‘’；
for （var I = 1；I <= 5；i++）{
	str = str + ‘☆’
}
console.log(str)；

```

# 3. 双重for循环

## 3.1 语法结构

```javascript
for （外层的初始化变量；外层的条件表达式；外层的操作表达式）{
	for （里层的初始化变量；里层的条件表达式；里层的操作表达式）{
	  // 执行语句；
}
}

```

●我们可以把里面的循环看作是外层循环的语句

●外层循环 循环一次，里面的循环执行全部

## 3.2 例题：打印五行五列星星

```javascript
var str = ‘’；
for （var I = 1；I <= 5；i++）{ //外层循环负责打印五行
	for （var j = 1； j < 5；j++）{ //里层循环负责一行打印五个星星
		str = str + ‘☆’；
}
	//如果一行打印完毕5个星星就要另起一行 加 \n
	str = str + ‘\n’；
}
console.log（str）；

```

## 3.3 for循环小结

●for循环可以重复执行某些相同代码

●for循环可以重复执行些许不同的代码，因为我们有计数器

●for循环可以重复执行某些操作，比如算术运算符加法操作

●随着需求增加，双重for循环可以做更多、更好看的效果

●双重for循环、外层循环一次，内层for循环全部执行

●for循环是循环条件和数字直接相关的循环

●分析要比写代码重要

●一些核心算法想不到，但是要学会，分析它执行过程

# 4.while循环

while语句可以在条件表达式为真的条件下，循环执行指定的一段代码，直到表达式不为真时结束循环。

## 4.1 语法结构

```javascript
while （条件表达式）{
	//循环体
}
```

执行思路：当条件表达式结果为true 则执行循环体 否则 退出循环

里面应该也有计数器 初始化变量

里面应该也有操作表达式 完成计数器的更新 防止死循环

```javascript
例; var num = 1；
	while （num <= 100）{
		console.log(‘您好’)；
		num++；
}

```

# 5.do while循环

do…while语句其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会执行循环体，否则退出循环。

## 5.1 **do…while语句的语法结构如下;**

```javascript
do { 
	//循环体代码-条件表达式为true时重复执行循环体代码
} while（条件表达式）；

```

### **执行思路：**

先执行一次循环体代码

再执行条件表达式，如果结果为true，则继续执行循环体代码，如果为false，则退出循环，继续执行后面代码

**注意：先执行循环体，再判断，我们会发现do…while循环语句至少会执行一次循环体代码**

```javascript
例; var i = 1；
	do {
		 console.log（‘how are you’）；
		 i++；
}while （i <= 100）

```

# 6. 循环小结

●JS中循环有for、while、do while

●三个循环很多情况下都可以相互替代使用

●如果是用来计次数，跟数字相关的，三者使用基本相同，但是我们更喜欢用for

●while和do…while可以做更复杂的判断条件，比for循环灵活一些

●while和do…while执行顺序不一样，while是先判断后执行，do…while先执行一次，再判断执行

●while和do…while执行次数不一样，do…while至少会执行一次循环体，而while可能一次也不执行

●实际工作中，我们更常用for循环语句，它写法更简洁直观，所以这个要重点学习

# 7.continue break 关键字

## 7.1 continue关键字

**continue关键字**用于立即**跳出本次（当前次）循环，继续下一次循环**（本次循环体中continue之后的代码就会少执行一次）。

## 7.2 break关键字

**break关键字用于**立即**跳出整个循环**（循环结束）。

### 1.标识符命名规范

●变量、函数的命名必须要有意义

●变量的名称一般用名词

●函数的名称一般用动词

// 操作符的左右两侧各保留一个空格

// 单行注释前注意要有个空格

![image-20220119224519353](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119224519353.png)

# 1.数组的概念

使用（arrgy）。可以把一组相关的数据一起存放，并提供方便的访问（获取）方式。

是指一组数据的集合，其中的每个数据被称作元素，在中可以存放任意类型的元素。是一种将一组数据存储在单个变量名下的优雅方式。

```javascript
例：// 普通变量一次只能存储一个值
		var num = 10；
	// 一次可以存储多个值
		var arr = [1,2,3,4]；

```

# 2.创建数组

## 2.1 数组的创建方式

JS中创建有两种方式：

●利用new创建

●利用字面量创建

## 2.2 利用new创建

```javascript
var 名 = new Array（）；
var arr = new Array（）；// 创建一个新的空

```

●这种方式暂且了解，等学完对象再看

●注意Array（），A要大写

## 2.3 利用字面量创建

```javascript
// 1.使用字面量方式创建空的
var 名 = []；
// 2.使用字面量方式创建带初始值的
var arr = [‘小白‘， ‘小黑’， true ，8]；
```

●数组的字面量是方括号[]

●声明并赋值称为的初始化

●我们里面的数据一定用逗号分隔

●里面的数据  比如true，‘小白’我们称为元素

●这种字面量方式也是我们以后最多使用的方式

## 2.4 元素的类型

数组中可以存放任意类型的数据，例如字符串、数字、布尔值等。

```javascript
var arr = [‘小白‘， ‘小黑’， true ，8]；
```

# 3.获取数字元素

## 3.1 数组的索引

**索引（下标）**：用来访问元素的序号（**下标从0开始**）。

![image-20220119224948011](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119224948011.png)

可以通过**索引**来访问、设置、修改对应的元素，我们可以通过'**数组名[索引]**'的形式来获取中的元素。

这里的**访问**就是获取得到的意思

```javascript
// 定义
var arrStus = [1,2,3]；
// 获取中的第2个元素
alert(arrStus[1])；
// 没有这个元素 所以输出的结果是 underfined
alert(arrStus[3])；
```

# 4.遍历数组

![image-20220119225128357](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119225128357.png)

**规律：**

从代码中我们可以发现，从数组中取出每一个元素时，代码是重复的，有所不一样的是**索引值在递增，**

**循环 可以把数组里面的元素全部取出来**

## 4.1 数组遍历概念

遍历：就是把数组中的每个元素从头到尾都访问一次（类似我们每天早上学生的点名）。

![image-20220119225205875](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119225205875.png)

## 4.2 数组长度

长度 名.length

![image-20220119225247112](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119225247112.png)

数组的长度是元素个数  不要跟索引号（从0开始）混淆

arr.length 动态检测元素的个数

# 5.数组中新增元素

可以通过修改length长度以及索引号增加元素

## 5.1 通过修改length长度新增数组元素

●可以通过修改length长度来实现扩容的目的

●length属性是可读写的

```javascript
var arr = [‘red’,‘green’，‘blue’，‘pink’]；
arr.length = 7；
console.log(arr)；
console.log(arr[4])；
console.log(arr[5])；
console.log(arr[6])；
```

其中索引号是4,5,6的空间没有给值，就是声明变量未给值，默认值就是**underfined。**

![image-20220119225422808](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119225422808.png)

## 5.2 数组通过修改索引新增元素

●可以通过修改索引的方式追加元素

●不能直接给数组名赋值，否则会覆盖掉以前的数据。

●在原来存在的元素，重新赋值给他，会替换原来的元素

## 5.3 筛选方法

![image-20220119225548229](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119225548229.png)

5.4 排序（冒泡排序）

**冒泡排序：**是一种算法，把一系列的数据按照一定的顺序进行排列显示（从小到大或者从大到小）。

冒泡排序是一种简单的排序算法，它重复着走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来，走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢‘浮’到数列的顶端。

# 1.函数的概念

在JS里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。

虽然for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用**JS中的函数**

**函数：**就是封装了一段**可被重复调用执行的代码块**，通过此代码块可以实现大量代码的重复使用。

# 2.函数的使用

函数在使用时分为两步：声明函数和调用函数。

## 2.1 声明函数

```javascript
// 声明函数
function 函数名（）{
	// 函数体代码
}

```

●function是声明函数的关键字，**必须小写**。

●由于函数一般是为了实现某个功能才定义的，所以通常我们将函数名命名为**动词**，比如getSum。

## 2.2 调用函数

**//** **调用函数**

**函数名（）：****//** **通过调用函数名来执行函数体代码**

●调用的时候千万**不要忘记添加小括号**

●口诀：函数不调用，自己不执行。

**注意：**声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。

## 2.3 函数的封装

●函数的封装是把一个或者多个功能通过**函数的方式封装起来**，对外只提供一个简单的函数接口。

●简单理解：封装类似于将电脑配件整合组装到机箱中（类似快递打包）

# 3.函数的参数

## 3.1 形参和实参

在**声明函数时**，可以在函数名称后面的小括号中添加一些参数，这些参数被称为**形参**，而在调用该函数时，同样也需要传递相应的参数，这些参数被称为**实参。**

| **参数** | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| **形参** | 形式上的参数 **函数定义**的时候  传递的参数 当前并不知道是什么 |
| **实参** | 实际上的参数 **函数调用**的时候传递的参数  实参是传递给形参的 |

**参数的作用：**在**函数内部**某些值不能固定，我们可以通过参数在**调用函数时传递**不同的值进去。

```javascript
function 函数名（形参1，形参2…）{ // 在声明函数的小括号里面是形参 （形式上的参数）

}
函数名（实参1，实参2…）
```

![image-20220119225927656](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119225927656.png)

形参是接受实参的 形参可以看做是不用声明的变量

## 3.2 函数形参和实参个数不匹配问题

| **参数个数**         | **说明**                           |
| -------------------- | ---------------------------------- |
| 实参个数等于形参个数 | 输出正确结果                       |
| 实参个数多于形参个数 | 只取到形参的个数                   |
| 实参个数小于形参个数 | 多的形参定义为undefined，结果为NaN |

![image-20220119230010765](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119230010765.png)

**注意：**在JavaScript中，形参的默认值是**undefined**

## 3.3 函数小结

●函数可以带参数也可以不带参数

●声明函数的时候，函数名括号里面的是形参，形参的默认值为undefined

●调用函数的时候，函数名括号里面的是实参

●多个参数中间用逗号分隔

●形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量匹配。

# 4.函数的返回值

## 4.1 return语句

有的时候，我们会希望函数将值返回给调用者，此时通过使用return语句就可以实现。

```javascript
函数的返回值格式：
function 函数名（）{
	return 需要返回的结果；
}
函数名（）；

```

（1） 我们函数只是实现某种功能，最终的结果需要返回给函数的调用者 函数名（） 通过return实现的

（2） 只要函数遇到return 就把后面的结果 返回给函数的调用者 函数名（） = return后面的结果

## 4.2 return终止函数

return语句之后的代码不被执行。

return语句只能返回一个值

![image-20220119230225340](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119230225340.png)

## 4.3 **return语句可以结合使用**

![image-20220119230249224](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119230249224.png)

## **4.4 函数没有return返回underfined**

函数都是有返回值的

1. 如果有return则返回retrun后面的值

2. 如果没有return则返回underfined

## **4.5 break**，continue，return的区别

●break：结束当前的循环体（如if、while）

●continue：跳出本次循环，继续执行下次循环（如for、while）

●return：不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码

# **5.通过榨汁机看透函数**

①输入参数 

②内部处理

③返回结果

![image-20220119230426104](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119230426104.png)

# 6. **arguments的使用**

当我们不确定有多少个参数传递的时候，可以用**arguments**来获取。在JavaScript中，只有函数才有argunments对象，arguments实际上它是当前函数的一个**内置对象**。所有函数都内置了一个arguments对象，arguments对象中**存储了传递的所有实参。**

**arguments**展示形式是一个伪，伪 并不是真正意义上的 因此可以进行遍历。伪具有以下特点：

●具有length属性

●按索引方式储存数据

●不具有的push（），pop（）等方法

# **7.函数可以调用另外一个函数**

因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况。

![image-20220119230532332](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119230532332.png)

# 8.函数的两种声明方式

## **8.1利用函数关键字自定义函数（命名函数）**

```javascript
function fn(){

}
fn();
```

## 8.2 函数表达式（匿名函数）

```javascript
var 变量名 = function() {}；
例：var fun = function() {
		console.log(‘我是函数表达式’)；
}；
fun()；
```

（1） fun是变量名 不是函数名

（2） 函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值 而 函数表达式里面存的是函数

（3） 函数表达式也可以进行传递参数

# 1.作用域

## 1.1作用域概述

通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的**可用性的代码范围就是**这个名字的**作用域**。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

●JavaScript作用域：就是代码名字（变量）在某个范围内起作用和效果 目的就是为了提高程序的可靠性更重要的是减少命名冲突。

●Js的作用域（es6）之前 ： 全局作用域  局部作用域

●全局作用域; 整个script标签 或者是一个单独的js文件

***例：var num = 10；\***

●局部作用域：在函数内部就是局部作用域 这个代码的名字只在函数内部起效果和作用

```javascript
例：function fn() {
	// 局部作用域
}
fn();

```

## 1.2Js中没有块级作用域

Js的作用域：全局作用域  局部作用域  现阶段我们js没有 块级作用域

我们Js也是在 es6 的时候新增的块级作用域

# 2.**变量的作用域**

## 2.1 变量作用域的分类

在JavaScript中，根据作用域的不同，变量可以分为两种：

●全局变量

●局部变量

## 2.2 全局变量

在全局作用域下声明的变量叫做**全局变量（在函数外部定义的变量）。**

●全局变量在代码的任何位置都可以用

●在全局作用域下var声明的变量 是全局变量

●特殊情况下，在函数内不使用var声明的变量也是全局变量（不建议使用）

## 2.3局部变量

在局部作用域下声明的变量叫做**局部变量（在函数内部定义的变量）。**

●局部变量只能在该函数**内部**使用

●在函数内部var声明的变量是局部变量

●函数的**形参**实际上就是局部变量

## 2.4 **全局变量和局部变量的区别**

●全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存

●局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间。

# 3.作用域链

只要是代码，就至少有一个作用域

●作用域链：内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值 这种结构我们称为作用域链  就近原则

●写在函数内部的局部作用域

●如果函数中海油函数，那么在这个作用域就又可以诞生一个作用域

●根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链

![image-20220119231135414](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119231135414.png)

# 1.预解析

JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行**JavaScript代码的时候分为两步：预解析和代码执行。**

（1） 预解析：js引擎会把js里面所有的var 还有 function提升到当前作用域的最前面

（2） 代码执行：按照代码书写的顺序从上往下执行

### 2.预解析分为 变量预解析（变量提升）和函数预解析（函数提升）

**（1）** 变量提升：就是把所有的变量声明提升到当前的作用域最前面**不提升赋值操作**

**（2）** 函数提升：就是把所有的函数声明提升到当前作用域的最前面**不调用函数**

![image-20220119231306654](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119231306654.png)

![image-20220119231328365](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119231328365.png)

**按照预解析排列好，再用作用域链查找结果**

# 1.对象

## 1.1 什么是对象

在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、、函数等

对象是由**属性**和**方法**组成的。

●属性：事物的**特征**，在对象中用**属性**来表示（常用名词）

●方法：事物的**行为**，在对象中用**方法**来表示（常用动词）

![image-20220119231424006](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119231424006.png)

## 1.2 为什么需要对象？

保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用。如果要保存一个人的完整信息呢？

例如，将“张三疯”的个人的信息保存在中的方式为：

```javascript
var arr = {‘张三疯’，‘男’，128,154};
```

JS中的对象表达结构更清晰，更强大。张三疯的个人信息在对象中的表达结构如下：

![image-20220119231537163](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119231537163.png)

# 2.创建对象的三种方式

在JavaScript中，现阶段我们可以采用三种方式创建对象（object）

●利用**字面量**创建对象

●利用**new Object**创建对象

●利用**构造函数**创建对象

## 2.1 利用字面量创建对象

对象字面量：就是花括号{}里面包含了表达这个具体事物（对象）的属性和方法。

{}里面采取键值对的形式表示

●键：相当于属性名

●值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型、函数类型等）

●多个属性或者方法中间用英文逗号隔开的

●方法冒号后面跟的是一个匿名函数

### **对象的调用：**

对象里面的属性调用：**对象.属性名，**这个小点，就理解为“**的**”

对面里面属性的另一种调用方式：**对象[‘属性名’]**，注意方括号里面的属性**必须加引号**，我们后面会用

对象里面的方法调用：**对象.方法名(),**注意这个方法名字后面**一定加括号**

![image-20220119231645321](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220119231645321.png)

### 1.**变量、属性、函数、方法总结**

变量与属性的相同点 都是用来存储数据的

函数与方法的相同点 都是实现某种功能 做某件事

变量：单独声明赋值，单独存在

属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征

函数：单独存在的，通过“函数名()”的方式就可以调用

方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。

## **2.2利用new Object创建对象**

```javascript
var obj = new Object()；
obj.uname = ‘张三疯’;
obj.age = 18;
obj.sex = ‘男’;
obj.sayHi = function() {
	console.log(‘Hi’);
}
console.log(obj.uname);
console.log(obj[‘sex’]);
obj.sayHi();
```

（1） 我们是利用 等号（=）赋值的方法 添加对象的属性和方法

（2） 每个属性和方法之间用 分号结束

## 2.3 利用构造函数创建对象

### 1.为什么需要使用构造函数

●就是因为我们前面两种创建对象的方式一次只能创建一个对象，里面很多的属性和方法是大量相同的 我们只能复制

●因此我们可以利用函数的方法 重复这些相同的代码 我们就把这个函数称为 构造函数

●又因为我们这个函数不一样，里面封装的不是普通代码，而是 对象

●构造函数 就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面

### 2.利用构造函数创建对象

**构造函数**：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new运算符一起使用，我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

构造函数的语法格式：

```javascript
function 构造函数名() {
	this.属性 = 值；
	this.方法 = function() {}
}
new 构造函数名()；
```

（1） 构造函数名字首字母要大写

（2） 我们构造函数不需要return 就可以返回结果

（3） 我们调用构造函数 必须使用 new

（4） 我们只要new 构造函数名（） 调用函数就创建了一个对象  对象名{}

（5） 我们的属性和方法前面必须添加this

## 2.4 构造函数和对象

构造函数，如构造函数名（），抽象了对象的公共部分，封装到了函数里面，它**泛指某一大类（class）**

创建对象：如new 构造函数名（），**特指某一个，是一个具体的事物**，通过**new关键字创建对象的过程**我们也称为**对象实例化**

# 3.new关键字

new在执行时候会做四件事情：

（1） 在内存中创建一个新的空对象

（2） 让this指向这个新的对象

（3） 执行构造函数里面的代码，给这个新对象添加属性和方法

（4） 返回这个新对象（所以构造函数里面不需要return）

# 4.遍历对象属性

for...in语句用于对或者对象的属性进行循环操作（建议对对象遍历）

## 4.1语法结构

for in遍历我们的对象

```javascript
for (变量 in 对象) {

}
```

```javascript
var obj = {
		name: 'pink老师',
		age: 18,
		sex: '男',
		fn: function() {}
}
for (var k in obj) {
	console.log(k); // k 变量 输出 得到的是 属性名
	console.log(obj[k]); // obj[k] 得到是 属性值
}
```

我们使用for in 里面的变量 我们喜欢写 k 或者 key 很少使用来遍历方法

# 5.小结

1.对象可以让代码结构更清晰

2.对象复杂数据类型object

3.本质：对象就是一组无序的相关属性和方法的集合

4.构造函数泛指一大类，比如苹果，不管是红色苹果还是绿色苹果，都统称为苹果

5.对象实例特指一个事物，比如这个苹果，正在给你们讲课的pink老师等

6.for...in语句用于对对象的属性进行循环操作。

# 1.内置对象

●JavaScript的对象分为3种：自定义对象、内置对象、浏览器对象

●前面两种对象是JS基础内容，属于ECMAScript；第三个浏览器对象属于我们JS独有的，我们JS API讲解

●内置对象就是指JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）

●内置对象最大的优点就是帮助我们快速开发

●JavaScript提供了多个内置对象: Math、Date、Array、String等

# 2.查文档

## 2.1MDN

学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询

Mozilla开发者网络（MDN）提供了有关开发网络技术(Open Web)的信息，包括HTML、CSS和万维网及HTML5应用的API。

## 2.2 如何学习对象中的方法

1.查阅该方法的功能

2.查看里面参数的意义和类型

3.查看返回值的意义和类型

4.通过demo进行测试

## 2.3 Math对象

Math数学对象 不是一个构造函数，所以不需要new 来调用 而是直接使用里面的属性和方法即可

```javascript
console.log(Math.PI); // 一个属性 圆周率
Math.max() // 最大值 
Math.min() // 最小值
console.log(Math.max(1,45,37)); // 45
console.log(Math.max(4,45,'pink老师'); // NaN 不能转换为数字型的 就会输出NaN
console.log(Math.max()); // -Infinity
```

## 2.3 案列：封装自己的数学对象

```javascript
// 1.利用对象封装自己的数学对象，里面有PI最大值和最小值
var myMath = {
    PI: 3.141592653,
    max: function() {
        var max = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
            if (arguments[i] > max) {
                max = arguments[i];
            }
        }
        return max;
    },
    min:function() {
        var min = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
            if (arguments[i] < min) {
                min = arguments[i];
            }
        }
        return min;
}
}
console.log(myMath.PI); // 3.141592653
console.log(myMath.max(1, 5, 9)); // 9
console.log(myMath.min(1, 5, 9)); // 1
```

# 3.Math对象

## 3.1 Math概述

Math对象不是构造函数，它具有数学常数和函数的属性和方法，跟数学相关的运算(取绝对值，取整，最大值等)可以是由Math中的成员

```javascript
Math.PI // 圆周率
Math.floor() // 向下取整
Math.ceil() //  向上取整
Math.round() //四舍五入就近取整 注意负的点5 例-3.5 结果是-3
Math.abs() //  绝对值
Math.max()/Math.min() //  求最大值和最小值
```

### 1.绝对值方法

```javascript
console.log(Math.abs(1)); // 1
console.log(Math.abs(-1)); // 1
console.log(Math.abs('-1')); // 1 隐式转换 会把字符串型 -1 转换为数字型
console.log(Math.abs('pink')); // NaN
```

### 2.三个取整方法

```javascript
1.Math.floor() 向下取整 往最小了取值
```

```javascript
consloe.log(Math.floor(1.1)); // 1
consloe.log(Math.floor(1.9)); // 1
```

```
2.Math.ceil() 向上取整 往最大了取值
```

```javascript
consloe.log(Math.ceil(1.1)); // 2
consloe.log(Math.ceil(1.9)); // 2
```

```
3.Math.round() 四舍五入 其他数字都是四舍五入，但是 .5 特殊 
```

```javascript
consloe.log(Math.round(1.1)); // 1
consloe.log(Math.round(1.5)); // 2
consloe.log(Math.round(-1.1)); // -1
consloe.log(Math.round(-1.5)); // -1
```

## 3.2 随机数方法random（）

### 1.Math对象随机数方法 random（）返回一个随机的小数   0 =<x < 1

### 2.这个方法里面不跟参数

### 3.代码：

```javascript
console.log(Math.random()); 
```

### 4.我们想要得到两个数之间的随机整数 并且 包含这2个整数

```javascript
Math.floor(Math.radom() * (max - min + 1)) + min;
```

例：

```javascript
function getRandom(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(getRandom(1,10)); // 输出1~10 之间的随机整数
// 随机点名
var arr = ['张三', '李四', '张三疯', '李思思', 'pink老师'];
console.log(arr[getRandom(0, arr.length - 1)]);
```

# 4.日期对象

## 4.1 Date 概述

- Date对象和Math对象不一样，他是一个构造函数，所以我们需要实例化后才能使用

- Date实例用来处理日期和时间

Date() 日期对象 是一个构造函数 必须使用new 来调用创建我们的日期对象

```javascript
var arr = new Array(); //创建了一个数值对象
var obj = new Object(); //创建了一个对象实例
```



## 4.2 Date()方法的使用

### 1.获取当前时间必须实例化

```javascript
var now = new Date();
console.log(now);
```

### 2.Date()构造函数的参数

如果括号里面有时间，就返回参数里面的实际。例如日期格式 

字符串型为'2019-5-1'，可以写成new Date('2019-5-1')或者new Date('2019/5/1')

数字型为 2019，05, 01  可以写成new Date(2019，05, 01) **但是返回出来的月份比我们输入的要小一个月**

## 4.3 日期格式化

我们想要2019-8-8 8:8:8格式的日期，要怎么办？

```javascript
// 格式化日期 年月日
var date = new Date();
console.log(date.getFullYear()); // 返回当前日期的年2021
console.log(date.getMonth() + 1); // 月份 返回的月份小1个月 月份是0~11 所以记得月份+1
console.log(date.getDate()); // 返回的是 几号
console.log(date.getDay()); // 星期几 周一返回的是1 周六返回的是6 周日返回的是0
// 我们写一个 2022年 1月 21日 星期五
var year = date.getFullYear();
var month = date.getMonth();
var dates = date.getDate();
var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']; // 因为周日是0，整好和索引号一样写在里面的第一个
var day = date.getDay();
console.log('今天是：' + year + '年' + month + '月' + dates + '号 ' + arr[day])


// 格式化 时分秒
var date = new Date();
console.log(date.getHours()); // 时
console.log(date.getMinutes()); // 分
console.log(date.getSeconds()); // 秒
// 要求封装一个函数返回当前的时分秒 格式 08:08:08
function getTime() {
	var time = new Date();
    var h = time.getHours();
    h = h < 10 ? '0' + h : h; // 当小时小于10后 前面加0
    var m = time.getMinutes();
    m = m < 10 ? '0' + m : m;
    var s = time.getSeconds();
    s = s < 10 ? '0' + s : s;
    return h + ':' + m + ':' + s;
}
console.log(getTime());
```

## 4.4 获取日期的总的毫秒形式

Date对象是基于1970年1月1日(世界标准世界)起的毫秒数

我们经常利用总的毫秒数来计算时间，因为它更精确

获得Date总的毫秒数（时间戳）不是当前时间的毫秒数 而是距离1970年1月1号过了多少毫秒数

### 1.通过 valueOf()   getTime()

```javascript
var date = new Date();
console.log(date.valueOf()); // 就是 我们现在时间 距离1970.1.1 总的毫秒数
console.log(date.getTime());
```

### 2.简单的写法 （最常用的写法)

```javascript
var date = +new Date(); // +new Date() 返回的就是总的毫秒数
console.log(date);
```

### 3.H5 新增的  获得总的毫秒数

```javascript
console.log(Date.now());
```

## 4.6 倒计时案例

1. 核心算法：输入的时间减去现在的时间就是剩余的时间，即倒计时，但是不能拿着时分秒相减，比如05分减去25分，结果会是负数
2. 用时间戳来做。用户输入时间总的毫秒数减去现在时间的总的毫秒数，得到的就是剩余时间的毫秒数。
3. 把剩余时间总的毫秒数转换为天、时、分、秒（时间戳转换为时分秒）

- d = parseInt(总秒数/60/60/24)；// 计算天数
- h = parseInt(总秒数/60/60%24)；// 计算小时
- m = parseInt(总秒数/60%60)；// 计算分钟
- s = parseInt(总秒数%60)；//  计算当前秒数

```javascript
function countDown(time) {
    var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
    var inputTime = +new Date(time); // 返回的是用户输入时间总的毫秒数
    var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数
    var d = d = parseInt(times / 60 / 60 / 24);
    d = d < 10 ? '0' + d : d;
    var h = parseInt(times / 60 / 60 % 24);
    h = h < 10 ? '0' + h : h;
    var m = parseInt(times / 60 % 60);
    m = m < 10 ? '0' + m : m;
    var s = parseInt(times % 60);
    s = s < 10 ? '0' + s : s;
    return d + '天' + h + '时' + s + '秒';
}
console.log(countDown('2022-1-22 18:00:00'));
var date = new Date();
console.log(date);
```

# 5.对象

## 5.1创建的两种方式

### 1.利用字面量

```javascript
var arr = []; // 创建了一个空的
```

### 2.利用new Array()

```javascript
// var arr = new Array(); // 创建了一个空的
// var arr = new Array(2); // 这个2 表示 的长度为2 里面有2个空的元素(一个数表示的长度)
var arr = new Array(2,3); // 等价于[2,3] 这些写表示 里面有2个元素 是 2和3(两个及以上的数 表示元素)
```

## 5.2 检测是否为的两种方式

### 1.instanceof  运算符

```javascript
var arr = [];
var obj = {};
console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
```

### 2.Array.isArray(参数)； H5新增的方法  ie9以上版本支持

```javascript
var arr = [];
var obj = {};
console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false
```

例：翻转

```javascript
function reverse(arr) {
   // if (arr instanceof Array) {
      if (Array.isArray(arr)) {
        var newArr = [];
        for (var i = arr.length - 1; i >= 0; i--) {
            newArr[newArr.length] = arr[i];
        }
        return newArr;
    } else {
        return 'error 这个参数要求必须是格式[1,2,3]'
    }
}
console.log(reverse([1,2,3])); // 3,2,1
console.log(reverse(1,2,3)); // error 这个参数要求必须是格式[1,2,3]
```

## 5.3添加删除元素的方法

| 方法名            | 说明                                          | 返回值               |
| ----------------- | --------------------------------------------- | -------------------- |
| push(参数1...)    | 末尾添加一个或多个元素，注意修改原数组        | 并返回新的长度       |
| pop()             | 删除最后一个元素，把长度减1无参数，修改原数组 | 返回它删除的元素的值 |
| unshift(参数1...) | 向的开头添加一个或更多元素，注意修改原数组    | 并返回新的长度       |
| shift()           | 删除的第一个元素，长度减1无参数，修改原数组   | 并返回第一个元素的值 |

### 1.push() 在我们的末尾 添加一个或者多个元素 

```javascript
var arr = [1,2,3];
// arr.push(4,'pink');
console.log(arr.push(4,'pink')); // 返回的是新的长度
console.log(arr); // [1,2,3,4,'pink']
```

1. push 是可以给追加新的元素
2. push() 参数直接写 元素就可以了
3. push完毕之后，返回的结果是 新的长度
4. 原数组也会发生变化

### 2.unshift 在我们的开头 添加一个或者多个元素

```javascript
var arr = [1,2,3,4,'pink'];
// arr.unshift('red','purple');
console.log(arr.unshift('red','purple')); // 返回的是新的长度
console.log(arr); // ['red','purple',1,2,3,4,'pink']
```

1. unshift 是可以给前面追加新的元素
2. unshift() 参数直接写 元素就可以了
3. unshift完毕之后，返回的结果是 新的长度
4. 原数组也会发生变化

### 3.pop() 删除的最后一个元素

```javascript
var arr = [1,2,3,4,'pink'];
console.log(arr.pop()); // 返回的是删除的元素
console.log(arr); // [1,2,3,4]
```

1. pop 是可以删除的最后一个元素 记住一次只能删除一个元素
2. pop() 没有参数
3. pop完毕之后，返回的结果是 删除的那个元素
4. 原数组也会发生变化

### 4.shift() 删除的第一个元素

```javascript
var arr = [1,2,3,4];
console.log(arr.pop()); // 返回的是删除的那个元素
console.log(arr); // [2,3,4]
```

例：有一个包含工资的[1500,1200,2000,2100,1800]，要求把中工资超过2000的删除，其余的放在新里面

```javascript
var arr = [1500, 1200, 2000, 2100, 1800];
var newArr = [];
for (var i = 0; i <= arr.length; i++) {
if (arr[i] < 2000) {
// newArr[newArr.length] = arr[i]; // 把原小于2000的存在新里面
newArr.push(arr[i]); // 原小于2000的直接追加到新里面
}
}
console.log(newArr);
```

## 5.4 排序

### 1.翻转

```javascript
var arr = ['pink', 'red','blue','purple'];
arr.reverse();
console.log(arr);
```

### 2.排序（冒泡排序）

```javascript
var arr = [13,4,77,1,7];
// arr.sort(); // 里面只有一位数的时候 可以排序
arr.sort(function(a,b) {
	return a - b; // 升序的顺序排列
	return b - a; // 降序的顺序排列
});
console.log(arr);
```

## 5.5获取元素索引

### 1.indexOf(元素)

**index(元素)** 返回元素索引号方法

作用就是返回该元素的索引号  从**前面开始查找**

它只返回第一个满足条件的索引号

它如果在该里面找不到元素，则返回的是 -1

```javascript
var arr = ['red', 'green', 'blue', 'pink', 'blue'];
console.log(arr.indexOf('blue')); // 2 

var arr = ['red', 'green', 'pink'];
console.log(arr.indexOf('blue')); // -1
```

### 2.lastIndexOf(元素)

**lastIndexOf(元素)** 返回元素索引号方法

作用就是返回该元素的索引号  从**后面开始查找**

它只返回第一个满足条件的索引号

它如果在该里面找不到元素，则返回的是 -1

```javascript
var arr = ['red', 'green', 'blue', 'pink', 'blue'];
console.log(arr.lastIndexOf('blue')); // 4

var arr = ['red', 'green', 'pink'];
console.log(arr.lastIndexOf('blue')); // -1
```

## 5.6 去重（重点案例）

有一个['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b'],要求去除中重复的元素

1.目标：把旧里面不重复的元素选取出来放到新中，重复的元素只保留一个，放到新中去重。

2.核心算法：我们遍历旧，然后拿着旧元素去查询新，如果该元素在新里面没有出现过，我们就添加，否则不添加

3.利用新.indexOf(元素) 如果返回时 -1 就说明 新里面没有出现该元素

// 封装一个 去重的函数 unique 独一无二的

```javascript
function unique(arr) {
	var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) === -1) {
            newArr.push(arr[i]);
        }
    }
    return newArr;
}
var demo = unique(['c', 'a', 'z', 'a', 'x', 'a', 'x', 'c', 'b']);
console.log(demo);
```

## 5.7 转换为字符串

### 1.toString() 

```javascript
var arr = [1,2,3];
console.log(arr.toString()); // 1,2,3
```

### 2.join(分隔符)

```javascript
var arr = ['green','blue','pink'];
console.log(arr.join()); // green,blue,pink 默认逗号分隔
console.log(arr.join('-')); // green-blue-pink
console.log(arr.join('&')); // green&blue&pink
```

## 5.8 课下查询

| 方法名   | 说明                               | 返回值                                        |
| -------- | ---------------------------------- | --------------------------------------------- |
| concat() | 连接两个或多个 不影响原数组        | 返回一个新的数组                              |
| slice()  | 截取slice(begin,end)               | 返回被截取项目的新数组                        |
| splice() | 删除splice(第几个开始，要删除个数) | 返回被删除项目的新数组 注意，这个会影响原数组 |

slice()和splice()目的基本相同，建议重点看下splice()

## 5.9 splice() 方法

### **语法**

```js
array.splice(index, howmany, item1, ... ,itemX)
```

### 参数Values

| 参数              | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| index             | 必需。规定从何处添加/删除元素。<br/>该参数是开始插入和（或）删除的数组元素的下标，必须是数字。 |
| howmany           | 可选。规定应该删除多少元素。必须是数字，但可以是 "0"。<br/>如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。 |
| item1, ... ,itemX | 可选。要添加到数组的新元素                                   |

### 返回值

| Type  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| Array | 如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。 |



# 6.字符串对象

## 6.1 基本包装类型

为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String、Number和Boolean。

**基本包装类型**就是把简单数据类型包装称为复杂数据类型，这样基本数据类型就有了属性和方法。

```javascript
// 下面代码有什么问题？
var str = 'andy';
console.log(str.length); // 4
```

按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为js会把基本数据类型包装为复杂数据类型，其执行过程如下：

```javascript
// 1.生成临时变量，把简单数据类型包装为复杂数据类型
var temp = new String('andy');
// 2.赋值给我们声明的字符变量
str = temp;
// 3.销毁临时变量
temp = null;
```

## 6.2 字符串的不可变

指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

```javascript
var str = 'andy';
str = 'red';
// 当重新给str赋值的时候，常量'andy'不会被修改，依然在内存中
// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变
// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题
var str = '';
for (var i = 0; i < 100000; i++) {
    str += i;
}
console.log(str); // 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间
```

![image-20220123113641035](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220123113641035.png)

## 6.3 根据字符返回位置

字符串所有的方法，都不会修改字符串本身（字符串是不可变的），操作完成会返回一个新的字符串。

| 方法名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| indexOf('要查找的字符'，开始的位置) | 返回指定内容在原字符串的位置，如果找不到就返回-1，开始的位置是index索引号 |
| lastIndexOf()                       | 从后往前找，只找第一个匹配的                                 |

### 1.indexOf('要查找的字符'，开始的位置)

字符串对象 根据字符返回位置 

```javascript
var str = '改革春风吹满地，春天来了';
console.log(str.indexOf('春')); // 2
console.log(str.indexOf('春',3)); // 8  从索引号是 3的位置开始往后查找 
```

### 2.lastIndexOf('要查找的字符'，开始的位置)

```javascript
var str = '改革春风吹满地，春天来了';
console.log(str.lastIndexOf('春')); // 8
console.log(str.lastIndexOf('春', 7)); // 2  从索引号是7的位置开始往前查找
```

## 6.4 案例: 返回字符位置

查找字符串'abcoefoxyozzopp'中所有o出现的位置以及次数

解题思路：

核心算法：先查找都一个o出现的位置

然后 只有indexOf 返回的结果不是 -1 就继续往后查找

因为indexOf 只能查找到第一个，所以后面的查找，一定是当前索引号加1，从而继续查找

```javascript
var str = 'abcoefoxyozzopp';
var index = str.indexOf('o');
while (index !== -1) {
    console.log(index);
    str.indexOf('o',index + 1);
}
console.log(index);
```

## 6.5 根据位置返回字符(重点)

| 方法名            | 说明                                     | 使用                         |
| ----------------- | ---------------------------------------- | ---------------------------- |
| charAt(index)     | 返回指定位置的字符(index字符串的索引号)  | str.charAt(0)                |
| charCodeAt(index) | 获取指定位置处字符的ASCII码(index索引号) | str.charCodeAt(0)            |
| str[index]        | 获取指定位置处字符                       | HTML5,ie8+支持和charAt()等效 |

### 1.charAt(index)

根据位置返回字符

```javascript
var str = 'andy';
console.log(str.charAt(3)); // y
// 遍历所有的字符
for (var i = 0; i <= str.length; i++) {
    console.log(str.charAt(i)); 
}
```

### 2.charCodeAt(index)

返回相应索引号的字符ASCII值   目的; 判断用户按下了哪个键

```javascript
var str = 'andy';
console.log(str.charCodeAt(0)); // 97 a在ASCII码中是97
```

### 3.str[index] H5新增的

```javascript
var str = 'andy';
console.log(str[0]); // a 
```

## 6.6 返回字符位置

// 有一个对象

```javascript
var o = {
	age: 18
}
if (o['sex']) {
    console.log('里面有该属性');
} else {
    console.log('没有该属性');
}
输出结果为：没有该属性
```

判断一个字符串'abcoefoxyozzopp'中出现次数最多的字符，并统计其次数

核心算法：利用 charAt() 遍历这个字符串

把每个字符都存储给对象，如果对象没有该属性：就为1；如果存在了就+1

遍历对象：得到最大值和该字符

```javascript
var str = 'abcoefoxyozzopp';
var o = {};
for (var i = 0; i <= str.length; i++) {
    var chars = str.charAt(i); // chars是字符串的每一个字符
    if (o[chars]) { // o[chars]得到的是属性值
        o[chars]++;
    } else {
        o[chars] = 1;
    }
}
console.log(o);
// 遍历对象
var max = 0;
var ch = '';
for (var k in o) {
    // k 得到的是 属性名
    // o[k]得到的是 属性值
    if (o[k] > max) {
        max = o[k];
        ch = k; // k是我们遍历的属性 把k赋值给这个字符串存起来，k出了for循环就不起作用了。
    }
}
console.log('最多出现的次数是: ' + max);
console.log('出现最多的字符是: ' + ch);
```

## 6.7 字符串操作方法(重点)

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| concat(str1,str2,str3...) | concat()方法用于连续两个或多个字符串。拼接字符串，等效于+，+更常用 |
| substr(start,length)      | 从start位置开始(索引号)，length取的个数 重点记住这个         |
| slice(start,end)          | 从start位置开始，截取带end位置，end取不到(他们俩都是索引号)  |
| substring(start,end)      | 从start位置开始，截取带end位置，end取不到 基本和slice相同 但是不接受负值 |

### 1.concat('字符串1', '字符串2'...)

```javascript
var str = 'andy';
console.log(str.concat('red')); // andyred
```

### 2.substr('截取的起始位置', '截取几个字符');

```javascript
var str = '改革春风吹满地';
console.log(str.substr(2,2)); // 春风
```

## 6.8 替换字符和 字符转换为的方法

### 1.替换字符 replace('被替换的字符'，'替换为的字符')

```javascript
var str = 'andyandy';
console.log(str.replace('a', 'b')); //bndyandy  他只会替换第一个字符
```

例：有一个字符串'abcoefoxyozzopp' 要求把里面所有的 o 替换为'*'

```javascript
var str = 'abcoefoxyozzopp';
while (str.indexOf('o') !== -1) {
    str = str.replace('o', '*');
}
console.log(str)
```

### 2.字符转换为 split('分隔符')

join 把转换为字符串

```javascript
var str1 = 'red,'blue','pink';
console.log(str1.split(',')); // red,blue,pink

var str2 = 'red&blue&pink';
console.log(str2.split('&')); // red,blue,pink
```

split() ()里面的分隔符取决字符里面用的什么分隔符

- toUpperCase()  // 转换大写
- toLowerCase()  // 转换小写

# 1.简单类型与复杂类型

简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型。

- 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型string，number，boolean，undefined，null
- 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型通过new关键字创建的对象（系统对象，自定义对象）,如Object，Array，Date等

**简单数据类型 null**

```javascript
var timer = null;
console.log(typeof timer); // 返回的是一个空的对象 object
```

如果有个变量我们以后打算存储为对象，暂时没想好放啥，这个时候就给 null

# 2.堆和栈

堆栈空间分配区别：

1. 栈(操作系统)：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；

**简单数据类型存放到栈里面**

   2.堆(操作系统)：存储复杂类型(对象),一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。

**复杂数据类型存放到堆里面**

![image-20220123224616746](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220123224616746.png)

**注意：JavaScript没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来学习其他语言**

# 3.简单类型的内存分配

- 值类型(简单数据类型)：string，number，boolean，undefined，null
- 值类型变量的数据直接存放在变量(栈空间)中
- 简单数据类型 是存放在栈里面 里面直接开辟一个空间存放的是值

![image-20220123230010120](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220123230010120.png)

![image-20220123230040043](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220123230040043.png)

# 4.复杂类型的内存分配

- 引用类型(复杂数据类型)：通过new关键字创建的对象(系统对象、自定义对象)，如Object、Array、Date等
- 引用类型变量(栈空间)里存放的是地址，真正的对象实例存放在堆空间中
- 复杂数据类型 首先在栈里面存放地址 十六进制表示(系统自动分配) 然后这个地址指向堆里面的数据

![image-20220123230446024](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220123230446024.png)

![image-20220123230943534](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220123230943534.png)

# 5.简单类型传参

函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

```javascript
function fn(a) {
	a++;
	console.log(a); // 11
}
var x = 10;
fn(x);
console.log(x); // 10
```

![image-20220124112752619](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124112752619.png)

# 6.复杂类型传参

函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```javascript
function Person(name) {
	this.name = name;
}
function f1(x) { // x = p p的地址给了x
    console.log(x.name); // 2.刘德华
    x.name = '张学友';
    console.log(x.name); // 3.张学友
}
var p = new Person('刘德华');
console.log(p.name); // 1.刘德华
f1(p);
console.log(p.name); // 4.张学友
```

![image-20220124120042692](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124120042692.png)

# 1.Web APIs 和 JS基础关联性

## 1.1 JS的组成

![image-20220124120718573](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124120718573.png)

## 1.2 JS基础阶段以及Web APIs阶段

**JS基础阶段** 

------

- 我们学习的是ECMAScript标准规定的基本语法
- 要求同学们掌握JS基础语法
- 只学习基本语法，做不了常用的网页交互效果
- 目的是为了 JS 后面的课程打基础、做铺垫

------

**Web APIs阶段**

------

- Web APIs是 W3C组织的标准
- Web APIs 我们主要学习DOM 和 BOM
- Web APIs 是我们 JS 所独有的部分
- 我们主要学习页面交互功能
- 需要使用 JS 基础的课程内容做基础

------

JS 基础学习 ECMAScript 基础语法为后面作铺垫，Web APIs 是 JS 的应用，大量使用 JS 基础语法做交互效果

# 2.API 和 Web API

## 2.1 API

API(Application Programming Interface, 应用程序编程接口)是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

简单理解：**API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。**

比如手机充电的接口：

![image-20220124122807687](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124122807687.png)

## 2.2 Web API

**Web API 是浏览器**提供的一套操作**浏览器功能**和**页面元素**的**API**(BOM 和 DOM)。

现阶段我们主要针对于浏览器讲解常用的API，主要针对浏览器做交互效果。

比如我们想要浏览器弹出一个警示框，直接使用alert('弹出')

![image-20220124140616585](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124140616585.png)

因为Web API很多，所以我们将这个阶段称为**Web APIs**

## 2.3 API 和 Web API总结

1. API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现
2. Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。
3. Web API一般都有输入和输出(函数的传参和返回值)，Web API很多都是方法(函数)
4. 学习Web API可以结合前面学习内置对象方法的思路学习

# 1.DOM 简介

## 1.1 什么是 DOM

文档对象模型(Document Object Model, 简称 **DOM)**，是W3C组织推荐的处理可扩展标记语言(HTML或者XML)的标准**编程接口**。

W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。

## 1.2 DOM树

![image-20220124142253012](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124142253012.png)

- 文档：一个页面就是一个文档，DOM中使用document表示
- 元素：页面中的所有标签都是元素，DOM中使用element表示
- 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM使用node表示

document---元素节点，整个文档，根节点

html---元素节点

text---文本节点

attr---属性节点

comment---注释节点

**DOM把以上内容都看做是对象**

# 2.获取元素

## 2.1 如何获取页面元素

DOM在我们实际开发中主要用来操作元素。

获取页面中的元素可以使用以下几种方式：

- 根据ID获取
- 根据标签名获取
- 通过HTML5新增的方法来获取
- 特殊元素获取

## 2.2 根据 ID 获取

使用getElementById()方法可以获取带有ID的元素对象

1. 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
2. get 获得 element 元素 by 通过  驼峰命名法
3. 参数 id是大小写敏感的字符串
4. 返回的是一个元素对象
5. console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法

```html
<body>
    <div id="time">
        2022-1-24
    </div>
    <script>
        var timer = document.getElementById('time');
        console.log(timer); // <div id="time">2022-1-24</div>
        console.log(typeof timer); // object
        console.dir(timer); // 元素对象 更好的查看里面的属性和方法
    </script>
</body>
```

## 2.3 根据标签名获取

### 1.使用getElementsByTagName() 方法可以返回带有指定标签名的**对象的集合**

```javascript
document.getElementsByTagName('标签名');
```

**注意:**

1. **因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。**
2. **得到元素对象是动态的**

```html
<body>
  <ul>
        <li>知否知否，应是等你好久1</li>
        <li>知否知否，应是等你好久2</li>
        <li>知否知否，应是等你好久3</li>
        <li>知否知否，应是等你好久4</li>
        <li>知否知否，应是等你好久5</li>
  </ul>
  <script>
      // 1.返回的是 获取过来元素对象的集合 以伪的形式存储的
      var lis = document.getElementsByTagName('li');
      console.log(lis); // 伪
      console.log(lis[0]); // //<li>知否知否，应是等你好久1</li>
      // 2.我们想要依次打印里面的元素对象我们可以采取遍历的方式
      for (var i = 0; i < lis.length; i++) {
          console.log(lis[i]);
      }
    </script>
</body>
```

```html
<body>
    <ul>
        <li>知否知否，应是等你好久1</li>
    </ul>
    <script>
        // 3.如果页面中只有一个li 返回的还是伪的形式
        var lis = document.getElementsByTagName('li');
      	console.log(lis); // 伪
    </script>
</body>
```

```html
<body>
    <ul>
        
    </ul>
    <script>
        // 4..如果页面中没有这个元素 返回的空的伪的形式 长度为0
        var lis = document.getElementsByTagName('li');
      	console.log(lis); // 空的伪 长度为0
    </script>
</body>
```

### 2.还可以获取某个元素(父元素)内部所有指定标签名的子元素

```javascript
element.getElementsByTagName('标签名');
```

注意：父元素必须是**单个对象(必须指明是哪一个元素对象**)，获取的时候不包括父元素自己

element.getElementsByTagName('标签名'); 父元素必须是指定的单个元素

```html
<body>
    <ul>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
        <li>知否知否，应是等你好久</li>
    </ul>
    <ol id="ol">
        <li>生僻字</li>
        <li>生僻字</li>
        <li>生僻字</li>
        <li>生僻字</li>
        <li>生僻字</li>
    </ol>
    <script>
    // var ol = document.getElementsByTagName('ol'); // [ol]
    // console.log(ol[0].getElementsByTagName('li'));
        var ol = document.getElementById('ol');
        console.log(ol.getElementsByTagName('li'));
    </script>
</body>
```

## 2.4 通过HTML5新增的方法获取

### 1.document.getElementsByClassName('类名');  根据类名返回元素对象集合

```html
<body>
    <div class="box">盒子1</div>
    <div class="box">盒子2</div>
    <div id="nav">
        <ul>
            <li>首页</li>
            <li>产品</li>            
        </ul>
    </div>
    <script>
    	// 1.getElementsByClassName('类名') 根据类名获得某些元素集合
        var boxs = document.getElementsByClassName('box');
        console.log(boxs); // 伪
    </script>
</body>
```

### 2.document.querySelector('选择器')；根据指定选择器返回第一个元素对象

```html
<body>
    <div class="box">盒子1</div>
    <div class="box">盒子2</div>
    <div id="nav">
        <ul>
            <li>首页</li>
            <li>产品</li>            
        </ul>
    </div>
    <script>
    	// 2.querySeletor 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav
        var firstbox = document.querySelector('.box');
        console.log(firstbox); // 伪
        
        var nav = document.querySelector('#nav');
        console.log(nav); // <div id="nav">...</div>
        
        var li = document.querySelector('li');
        console,log(li); // <li>首页</li>
    </script>
</body>
```

### 3.document.querySelectorAll('选择器');  根据指定选择器返回所有元素对象

```html
<body>
    <div class="box">盒子1</div>
    <div class="box">盒子2</div>
    <div id="nav">
        <ul>
            <li>首页</li>
            <li>产品</li>            
        </ul>
    </div>
    <script>
    	// 3.quertSeletorAll() 返回指定选择器的所有元素对象集合
        var allBox = document.querySelectorAll('.box');
        console.log(allBox); 
        
        var lis = document.quertSelectorAll('li');
        console.log(lis);
    </script>
```

## 2.5 获取特殊元素(body , html)

### 1.获取body元素 document.body 返回body元素对象

```javascript
var bodyEle = document.body;
console.log(bodyEle);
```

### 2.获取html元素 document.documentElement 返回html元素对象

```javascript
var htmlEle = document.documentElement;
console.log(htmlEle);
```

# 3.事件的基础

## 3.1 事件概述

JavaScript使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为。

简单理解：触发---响应机制

网页中的每个元素都可以产生某些可以触发JavaScript的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作

## **3.2 事件是由三部分组成**(事件三要素)

事件源   事件类型   事件处理程序  我们也称为事件三要素

1. 事件源：事件被触发的对象  例  谁 ---> 按钮
2. 事件类型：如何触发  什么事件  例 鼠标点击(onclick) 还是鼠标经过 还是键盘按下
3. 事件处理程序：通过一个函数赋值的方式  完成

例题：点击一个按钮，弹出对话框

```html
<body>
    <button id="btn">唐伯虎</button>
    <script>
        var btn = document.getElementById('btn');
    	btn.onclick = function() {
				alert('点秋香');
		}
    </script>
</body>

```

## 3.3 执行事件的步骤

1. 获取事件源(获取元素)
2. 注册事件(绑定事件)
3. 添加事件处理程序(采取函数赋值形式)

例：

```html
<body>
    <div>123</div>
    <script>
        // 点击div 控制台输出 我被选中了
        // 1.获取事件源
        var div = document.querySelector('div');
        // 2.绑定事件 注册事件
        // div.onclick
        // 3.添加事件处理程序
        div.onclick = function() {
            console.log('我被选中了');
        }
    </script>
</body>
```

### **常见的鼠标事件**

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

# 4.操作元素

JavaScript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性

## 4.1 改变元素内容

```javascript
element.innerText
```

从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉

```javascript
element.innerHTML
```

起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行

```html
<html>
<head>
    <style>
        div {
            width:300px;
            height:30px;
            line-height:30px;
            color:#fff;
            background-color:hotpink;
        }
    </style>
</head>
<body>
    <button>显示当前系统时间</button>
    <div>某个时间</div>
    <p>今天的时间是</p>
    <script>
        // 当我们点击了按钮  div里面的文字后悔发生变化
        // 1.获取元素
    	var btn = document.querySelector('button');
        var div = document.querySelector('div');
        // 2.注册事件
        btn.onclick = function () {
            // div.innerText = '2022-1-25';
        }
        
        function getDate() {
            var date = new Date();
            // 我们写一个 2022年 1月 25日 星期二
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var dates = date.getDate();
            var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            var day = date.getDay();
            return '今天是: ' + year + '年' + month + '月' + dates + '日' + arr[day];
        }
        
        // 我们元素可以不用添加事件
        var p = document.querySelector('p');
        p.innerText = getDate();
    </script>
</body>
</html>
```

## 4.2 innerText和innerHTML的区别

### 1.innerText  不识别html标签  非标准 去除空格和换行

```html
<html>
    <body>
        <div></div>
        <p>
            我是文字
            <span>123</span>
        </p>
        <script>
            // 1.innerText  不识别html标签  非标准
        	var div = document.querySelector('div');
            div.innerText = '<strong>今天是: </strong> 2022'; // <strong>今天是: </strong> 2022
        </script>
    </body>
</html>
```

### 2.innerHTML  识别html标签  W3C标准  保留空格和换行

```html
<html>
    <body>
        <div></div>
        <p>
            我是文字
            <span>123</span>
        </p>
        <script>
            // 2.innerHTML  识别html标签  W3C标准
        	var div = document.querySelector('div');
            div.innerHTML = '<strong>今天是: </strong> 2022'; // 今天是: 2022
        </script>
    </body>
</html>
```

### 3.这两个属性是可读写的 可以获取元素里面的内容

```html
<html>
    <body>
        <div></div>
        <p>
            我是文字
            <span>123</span>
        </p>
        <script>
            // 3.这两个属性是可读写的 可以获取元素里面的内容
        	var p = document.querySelector('p');
            // console.log(p.innerText); // 我是文字 123
            console.log(p.innerHTML); // 保留空格和换行
        </script>
    </body>
</html>
```

## 4.3 常用元素的属性操作

1. innerText、innerHTML，改变元素内容
2. src、href
3. id、alt、title

```html
<html>
<body>
    <button id="ldh">刘德华</button>
    <button id="zxy">张学友</button>
    <img src="./images/ldh.jpg" alt="" title="刘德华">
    
    <script>
    	// 修改元素属性 
        // 1.获取元素
        var ldh = document.getElementById('ldh');
        var zxy = document.getElementById('zxy');
        var img = document.querySelector('img');
        // 2.注册事件
        zxy.oncilck = function() {
            img.src="./images/zxy.jpg"; // 元素.属性
            img.title="张学友";
        }
        ldh.oncilvk = function() {
            img.src="./images/ldh.jpg";
            img.title="刘德华";
        }
    </script>
</body>
</html>

```

## 4.4 表单元素的属性操作

利用DOM可以操作如下表单元素的属性：

type、value、checked、selected、disabled

```html
<html>
<body>
    <button>按钮</button>
    <input type="text" value="输入内容">
    <script>
        // 1.获取元素
        var btn = document.querySelector('button');
        var input = document.querySelector('input');
        // 2.注册事件 处理程序
        btn.onclick = function () {
            // input.innerHTML = '被点击了'; 这个是 普通盒子 比如 div 标签里面的内容 在表单里面不能使用
            input.value = '被点击了';
            // 如果想要某个表单被禁用 不能再点击 disabled 我们想要这个按钮button禁用
            // btn.disabled = true;
            this.disabled = true;
            // this 指向的是事件函数的调用者 指向btn
        }
    </script>
</body>

</html>
```

**仿京东显示隐藏密码**

点击按钮将密码框切换为文本框，并可以查看密码明文。

1. 核心思路：点击眼睛按钮，把密码框类型改为文本框就可以看见里面的密码
2. 一个按钮两个状态，点击一次，切换为文本框，继续点击一次切换为密码框
3. 算法：利用一个flag变量，来判断flag的值，如果是1就切换为文本框，flag设置为0，如果是0就切换为密码框，flag设置为1

```html
<html>
    <style>
        .box {
            position: relative;
            width: 400px;
            margin: 100px auto;
            border-bottom: 1px solid #ccc;
        }
        .box input {
            width:370px;
            heigth: 30px;
            border: 0;
            outline: none;
        }
        .box img {
            position: absolute;
            top: 2px;
            right: 2px;
            heigth: 30px;
        }
    </style>
 <body>
     <div class="box">
         <label for="">
         	<img src="./images/close.png" alt="" id="eye">
         </label>
         <input type="password" name="" id="pwd">
     </div>  
     <script>
     	// 1.获取元素 (元素越多 用id快捷一些)
         var eye = document.getElementById('eye');
         var pwd = document.getElementById('pwd');
        // 2.注册事件 处理程序
         var flag = 0;
         eye.onclick = function() {
             // 点击一次之后，flag一定要变化
             if (flag == 0) { // 判断操作
             	pwd.type="text";
                eye.src="./images/open.png";
                flag = 1; // 赋值操作
             } else {
                pwd.type="password";
                eye.src="./images/close.png"; 
                flag = 0;
             }
         }
     </script>
 </body>
</html>
```

## 4.5 样式属性操作

我们可以通过JS修改元素的大小、颜色、位置等样式。

1. element.style              行内样式操作  适合于样式比较少 或者 功能简单的情况下使用
2. element.className  类名样式操作  适合于样式较多 或者 功能复杂的情况下使用

### 1.element.style  行内样式操作

**注意：**

1. **JS里面的样式采取驼峰命名法 比如fontSize、backgroundColor**
2. **JS修改 style样式操作，产生的是行内样式，css权重比较高**

```html
<html>
    <style>
        div {
            width: 200px;
            height: 200px;
            background-color: hotpink;
        }
    </style>
 <body>
     <!-- <div style="width: 200px"></div> -->如果修改的样式较少 可以写在里面
  	 <div></div>  
     <script>
     	// 1.获取元素
         var div = document.querySelector('div');
        // 2.注册事件 处理程序
         div.onclick = function() {
             // div.style里面的属性 采取驼峰命名法
             div.style.backgrounfColor = 'purple';
         }
     </script>
 </body>
</html>
```

![image-20220127120115864](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220127120115864.png)

#### 案例1：关闭淘宝二维码案列

当鼠标点击二维码关闭按钮的时候，则关闭整个二维码。

1. 核心思路：利用样式的显示和隐藏完成，display: none隐藏元素  display: block显示元素
2. 点击按钮，就让这个二维码盒子隐藏起来即可

```html
<html>   
<head>
<style>
        .box {
            position: relative;
            width: 76px;
            height: 90px;
            border: 1px solid #ccc;
            margin: 100px auto;
            background-color: #eae8eb;
            color: #ff5000;
            font-size: 12px;
            text-align: center;
            display: block;
            /* display: block; 默认的就是这个 */
        }

        .box img {
            width: 66px;
            height: 66px;
            margin-left: 1px;
            margin-top: 3px;
        }

        .close-btn {
            position: absolute;
            top: -1px;
            left: -17px;
            width: 14px;
            height: 14px;
            border: 1px solid #ccc;
            line-height: 14px;
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div class="box">
        淘宝二维码
        <img src="./images/taobao.png" alt="">
        <i class="close-btn">x</i>
    </div>
    <script>
        // 1.获取元素
        var btn = document.querySelector('.close-btn');
        var box = document.querySelector('.box');
        // 2.注册事件(绑定事件) 程序处理
        btn.onclick = function () {
            box.style.display = 'none';
        }
    </script>
</body>

</html>
```

#### 案列2：循环精灵图背景

可以利用for循环设置一组元素的精灵图背景

1. 首先精灵图图片排列有规律的
2. 核心思路：利用for循环 修改精灵图片的 背景位置background-position
3. 剩下的就是考验你的数学功底了
4. 让循环里面的i索引号*44 就是每个图片的y坐标

![image-20220127170618245](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220127170618245.png)

```html
<html>
<head>
<style>
        * {
            padding: 0;
            margin: 0;
        }

        .box {
            width: 250px;
            margin: 100px auto;
        }

        .box li {
            float: left;
            width: 24px;
            height: 24px;
            background-color: hotpink;
            margin: 15px;
            list-style: none;
            background: url(./images/xuebitu.png) no-repeat;

        }
    </style>
</head>

<body>
    <div class="box">
        <ul>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>
    </div>
    <script>
        // 1.获取元素 所有的小li
        var lis = document.querySelectorAll('li');
        for (var i = 0; i < lis.length; i++) {
            // 让索引号 乘以 44 就是每个li 的背景y坐标
            var index = i * 44;
            lis[i].style.backgroundPosition = '0 -' + index + 'px';
        }
    </script>
</body>

</html>
```

#### 案例3：显示隐藏文本框内容

当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示。

1. 首先表单需要2个新事件，获得焦点onfocus 失去焦点onblur
2. 如果获得焦点，判断表单里面内容是否为默认文字，如果是默认文字，就清空表单内容
3. 如果失去焦点，判断表单内容是否为空，如果为空，则表单内容改为默认文字

```html
<html>
<head>
	<style>
        input {
            outline: none;
            border: 2px solid skyblue;
            color: #999;
        }
    </style>
</head>

<body>
    <input type="text" value="手机">
    <script>
        // 1.获取元素
        var input = document.querySelector('input');
        // 2.注册事件 获得焦点事件 onfocus
        input.onfocus = function () {
            if (this.value === '手机') {
                this.value = '';
            }
            // 获得焦点需要把文本框里面的文字颜色变黑
            this.style.color = '#333';
        }
        // 3.注册事件 失去焦点事件 onblur
        input.onblur = function () {
            if (this.value === '') { // 判断操作 利用属性的可读写性
                this.value = '手机'; // 赋值操作
            }
            // 失去焦点需要把文本框里面的文字颜色变黑
            this.style.color = '#999';
        }
    </script>
</body>

</html>
```

### 2.element.className  类名样式操作

**注意：**

1. **如果样式修改较多，可以采取操作类名方式更改元素样式。**
2. **class因为是个保留字，因此使用className来操作元素类名属性**
3. **className 会直接更改元素的类名，会覆盖原先的类名**
4. **如果想要保存原先的类名，我们可以使用多类名选择器  '旧类名 新类名***'

```html
<html>
<head>
<style>
        .first {
            width: 200px;
            height: 200px;
            line-height: 200px;
            text-align: center;
            background-color: black;
            font-size: 12px;
            color: skyblue;
        }

        .change {
            width: 300px;
            height: 300px;
            line-height: 300px;
            background-color: hotpink;
            font-size: 36px;
            color: purple;
        }
    </style>
</head>

<body>
    <div class="first">好好敲代码</div>
    <script>
        // 1.获取元素
        var change = document.querySelector('div');
        // 2.注册事件
        change.onclick = function () {
            // this.style.width = '300px';
            // this.style.height = '300px';
            // this.style.backgroundColor = 'hotpink';
            // this.style.fontSize = '36px';
            // this.style.lineHeight = '300px';
            // this.style.color = 'purple';


            // 让我们当前元素的类名改为了 change
            // 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况下使用
            // this.className = 'change';
            // 如果我们想要保留原先的类名，我们可以使用 多类名选择器
            this.className = 'first change';
        }
    </script>
</body>

</html>
```

#### 案列1：密码框格式提示错误信息

用户如果离开密码框，里面输入个数不是6~16，则提示错误信息，否则提示输入正确信息

1. 首先判断的事件是表单失去焦点onblur 感叹号的提示信息(提示的感叹号)
2. 如果输入正确则提示正确的信息颜色为绿色小图标变化
3. 如果输入不是6到16位，则提示错误信息颜色为红色 小图变化
4. 因为里面变化样式较多，我们采取className修改样式

```html
<html>
 <head>
<style>
        * {
            padding: 0;
            margin: 0;
        }

        .register {
            width: 400px;
            margin: 50px auto;
            /* background-color: hotpink; */
        }

        .ipt {
            outline: none;
            height: 20px;
        }

        .message {
            display: inline-block;
            background: url(./images/tishi.jpg) no-repeat left center;
            background-size: 20px;
            color: #999;
            padding-left: 22px;
            vertical-align: middle;
        }

        .wrong {
            /* 只需要修改背景图片就行 */
            background-image: url(./images/cuowu.jpg);
            color: red;
        }

        .right {
            background-image: url(./images/zhengque.jpg);
            color: green;
        }
    </style>
</head>

<body>
    <div class="register">
        <input type="password" class="ipt">
        <p class="message">请输入6~16位密码</p>
    </div>
    <script>
        // 1.获取元素
        var ipt = document.querySelector('.ipt');
        var mes = document.querySelector('.message');
        // 2.注册事件 失去焦点 onblur
        ipt.onblur = function () {
            // 根据表单里面值的长度 ipt.value.length
            if (this.value.length < 6 || this.value.length > 16) {
                mes.className = 'message wrong';
                mes.innerHTML = '请您重新输入6~16的密码';
            } else {
                mes.className = 'message right';
                mes.innerHTML = '恭喜您输入正确';
            }
        }
    </script>
</body>

</html>
```

## 4.6 操作元素总结

操作元素是DOM核心内容

![image-20220127221939890](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220127221939890.png)

## 4.7 排他思想(算法)重点

如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：

1. 所有元素全部清除样式
2. 给当前元素设置样式
3. 注意顺序不能颠倒，首先先清除所有元素样式，再设置当前元素样式

```html
<html>
<body>
    <button>按钮1</button>
    <button>按钮2</button>
    <button>按钮3</button>
    <button>按钮4</button>
    <button>按钮5</button>
    <script>
        // 1.获取所有按钮元素
        var btns = document.getElementsByTagName('button');
        // btns得到的是伪 里面的每一个元素 btns[i]
        for (var i = 0; i < btns.length; i++) {
            btns[i].onclick = function () {
                // (1) 我们先把所有的按钮背景颜色去掉 
                for (var i = 0; i < btns.length; i++) {
                    btns[i].style.backgroundColor = '';
                }
                // (2) 然后才让当前的元素背景颜色为pink
                this.style.backgroundColor = 'pink';
            }
        }
        // 首先清除所有的按钮的背景颜色 然后才设置自己的样式
    </script>
</body>

</html>
```

### 案列1：百度换肤

1. 这个案列练习的是给一组元素注册事件
2. 给4个小图片利用循环注册点击事件
3. 当我们点击了这个图片，让我们页面背景改为当前的图片

```html
<html>  
<head>
<style>
        * {
            padding: 0;
            margin: 0;
        }

        body {
            background: url(./images/spring.jpg) no-repeat;
            background-size: cover;
        }

        li {
            list-style: none;
        }

        .baidu {
            margin: 100px 500px;
        }

        .baidu li {
            float: left;
            width: 100px;
            height: 100px;
        }

        .baidu li img {
            width: 100%;
            height: 100%;
        }
    </style>

</head>

<body>
    <ul class="baidu">
        <li><img src="./images/spring.jpg" alt=""></li>
        <li><img src="./images/summer.jpg" alt=""></li>
        <li><img src="./images/autumen.jpg" alt=""></li>
        <li><img src="./images/winter.jpg" alt=""></li>
    </ul>
    <script>
        // 1.获取元素
        var imgs = document.querySelector('.baidu').querySelectorAll('img');
        var bodyEle = document.body;
        // 2.循环注册事件
        for (var i = 0; i < imgs.length; i++) {
            imgs[i].onclick = function () {
                // this.src 就是我们点击图片的路径 ./images/spring.jpg
                // console.log(this.src);
                // 把这个路径 this.src 给body就可以了
                bodyEle.style.backgroundImage = 'url(' + this.src + ')';
            }
        }
    </script>
</body>

</html>
```

### 案列2：表格换行变色

1. 用到新的鼠标事件 鼠标经过onmouseover  鼠标离开 onmouseout
2. 核心思路：鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色
3. 注意：第一行(thead里面的行) 不需要变换颜色，因此我们获取的是tbody里面的行

```html
<html>   
<head>
<style>
        table {
            width: 800px;
            margin: 100px auto;
            text-align: center;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead tr {
            height: 30px;
            background-color: skyblue;
            text-align: center;
        }

        thead th {
            text-align: center;
        }

        tbody tr {
            height: 30px;
            border-bottom: 1px dashed #000;
        }

        tbody td {
            font-size: 12px;
            color: blue;
        }

        .bg {
            background-color: pink;
        }
    </style>
</head>

<body>
    <table>
        <thead>
            <tr>
                <th>基金代码</th>
                <th>基金名称</th>
                <th>单位净值</th>
                <th>累计净值</th>
                <th>近三个月(%)</th>
                <th>近六个月(%)</th>
                <th>近一年(%)</th>
                <th>今年以来(%)</th>
                <th>成立以来(%)</th>

            </tr>
        </thead>
        <tbody>
            <tr>
                <th>008952</th>
                <th>中信建投桂企债A</th>
                <td>1.2116</td>
                <td>1.2336</td>
                <td>19.45181</td>
                <td>19.9723</td>
                <td>22.6517</td>
                <td>18.4013</td>
                <td>23.8046</td>
            </tr>
            <tr>
                <th>008953</th>
                <th>中信建投桂企债C</th>
                <td>1.2019</td>
                <td>1.2219</td>
                <td>19.3901</td>
                <td>19.0707</td>
                <td>21.6031</td>
                <td>18.3788</td>
                <td>22.5759</td>
            </tr>
            <tr>
                <th>159981</th>
                <th>建信局盛郑商所能源化工期贷ETF</th>
                <td>1.6394</td>
                <td>1.6394</td>
                <td>-2.6831</td>
                <td>19.0041</td>
                <td>67.9025</td>
                <td>14.0770</td>
                <td>63.9230</td>
            </tr>
            <tr>
                <th>159981</th>
                <th>广发道琼斯石油指数(QDII-LOF)A现汇</th>
                <td>0.2288</td>
                <td>0.2288</td>
                <td>6.0732</td>
                <td>36.3528</td>
                <td>81.2995</td>
                <td>13.6048</td>
                <td>63.0791</td>
            </tr>
            <tr>
                <th>006680</th>
                <th>广发道琼斯石油指数(QDII-LOF)C现汇</th>
                <td>0.2282</td>
                <td>0.2282</td>
                <td>5.8933</td>
                <td>35.7525</td>
                <td>79.6850</td>
                <td>13.5323</td>
                <td>61.2721</td>
            </tr>
            <tr>
                <th>162719</th>
                <th>广发道琼斯石油指数(QDII-LOF)A</th>
                <td>1.4468</td>
                <td>1.4468</td>
                <td>4.9775</td>
                <td>33.1493</td>
                <td>76.7408</td>
                <td>12.6704</td>
                <td>44.6800</td>
            </tr>
            <tr>
                <th>004243</th>
                <th>广发道琼斯石油指数(QDII-LOF)C</th>
                <td>1.4432</td>
                <td>1.4432</td>
                <td>4.8152</td>
                <td>32.5739</td>
                <td>75.2945</td>
                <td>12.6180</td>
                <td>44.3200</td>
            </tr>
            <tr>
                <th>163208</th>
                <th>诺安油气能源(QDII-FOF-LOF)</th>
                <td>0.7760</td>
                <td>0.7760</td>
                <td>4.7233</td>
                <td>23.7640</td>
                <td>48.6590</td>
                <td>12.4638</td>
                <td>-22.4000</td>
            </tr>
            <tr>
                <th>003322</th>
                <th>易原油(QDII-LOF-FOF)A美元汇</th>
                <td>0.1544</td>
                <td>0.1544</td>
                <td>3.2085</td>
                <td>21.1931</td>
                <td>64.9573</td>
                <td>11.8841</td>
                <td>6.7035</td>
            </tr>
            <tr>
                <th>003323</th>
                <th>易原油(QDII-LOF-FOF)C美元汇</th>
                <td>0.1498</td>
                <td>0.1498</td>
                <td>3.1680</td>
                <td>20.9040</td>
                <td>64.2544</td>
                <td>11.8745</td>
                <td>3.5246</td>
            </tr>
        </tbody>
    </table>
    <script>
        // 1.获取元素 获取的是 tbody 里面所有的行
        var trs = document.querySelector('tbody').querySelectorAll('tr');
        // 2.利用循环注册事件
        for (var i = 0; i < trs.length; i++) {
            // 3.鼠标经过事件 onmouseover
            trs[i].onmouseover = function () {
                // this.style.backgroundColor = 'pink';
                this.className = 'bg';
            }
            // 4.鼠标离开事件 onmouseout
            trs[i].onmouseout = function () {
                // this.style.backgroundColor = '';
                this.className = '';
            }
        }
    </script>
</body>

</html>
```

### 案列3：表单全选取消全选案列

![image-20220130143600404](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220130143600404.png)

1. 全选和取消全选做法：让下面所有复选框的checked属性(选中状态)跟随 全选按钮即可
2. 下面复选框需要全部选中，上面全选才能选中做法：给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的，上面全选就不选中
3. 可以设置一个变量，来控制全选是否选中

```html
<html>
<head>
<style>
        * {
            padding: 0;
            margin: 0;
        }

        table {
            height: 30px;
            width: 300px;
            margin: 100px auto;
            text-align: center;
            border: 1px solid #000;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead tr {
            height: 30px;
            line-height: 30px;
            background-color: #008DD0;
        }

        thead tr th {
            border: 1px solid #000;
        }

        tbody tr {
            height: 30px;
            line-height: 30px;
            background-color: #EEF1EE;
        }

        tbody tr td {
            border: 1px solid #000;
        }
    </style>
</head>

<body>
    <table>
        <thead>
            <tr>
                <th>
                    <input type="checkbox" id="jb_All">
                </th>
                <th>商品</th>
                <th>价钱</th>
            </tr>
        </thead>
        <tbody id="jb_tbs">
            <tr>
                <td>
                    <input type="checkbox" id="jb_tb">
                </td>
                <td>iphone 12</td>
                <td>4000</td>
            </tr>
            <tr>
                <td>
                    <input type="checkbox" id="jb_tb">
                </td>
                <td>ipad 2021</td>
                <td>6500</td>
            </tr>
            <tr>
                <td>
                    <input type="checkbox" id="jb_tb">
                </td>
                <td>iphone Watch</td>
                <td>2000</td>
            </tr>
            <tr>
                <td>
                    <input type="checkbox" id="jb_tb">
                </td>
                <td>iphone XR</td>
                <td>3000</td>
            </tr>
        </tbody>
    </table>
    <script>
        // 1.全选和取消全选做法：让下面所有复选框的checked属性(选中状态)跟随全选按钮即可
        // 获取元素
        var jb_All = document.getElementById('jb_All'); // 全选按钮
        var jb_tbs = document.getElementById('jb_tbs').getElementsByTagName('input');  // 下面所有的复选框
        // 注册事件
        jb_All.onclick = function () {
            // this.checked 它可以得到当前复选框的选择状态如果是true 就是选中，如果是false 就是未选中
            for (var i = 0; i < jb_tbs.length; i++) {
                jb_tbs[i].checked = this.checked;
            }
        }
        // 2.下面复选框需要全部选中，上面全选才能选中做法：给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的，上面全选就不选中
        for (var i = 0; i < jb_tbs.length; i++) {
            jb_tbs[i].onclick = function () {
                // flag 控制全选按钮是否选中
                var flag = true;
                // 每次点击下面的复选框都要循环检查4个小按钮是否全被选中
                // 这里的循环与上个循环的作用域不一样 变量互相不影响
                for (var i = 0; i < jb_tbs.length; i++) {
                    if (!jb_tbs[i].checked) {
                        flag = false;
                        break; // 退出for循环 这样可以提高执行效率 因为只要有一个没有选中，剩下的就无需循环判断了
                    }
                    jb_All.checked = flag;
                }
            }
        }
    </script>
</body>

</html>
```

## 4.8 自定义属性的操作

### 1.获取属性值

- element.属性	获取属性值。
- element.getAttribute('属性');

**区别：**

- element.属性	获取内置属性值(元素本身自带的属性)
- element.getAttribute('属性');    主要获得自定义的属性(标准) 我们程序员自定义的属性

```html
<body>
    <div id="demo" index='1'></div>
    <script>
    	var div = document.querySelector('div');
        // 1.获取元素的属性值
        // (1) element.属性
        console.log(div.id); // demo
        // (2) element.getAttribute('属性') get 得到获取 attribute 属性
        // 我们程序员自己添加的属性我们称为自定义属性 index
        console.log(div.getAttribute('id')); // demo
        console.log(div.getAttribute('index')); // 1
    </script>
</body>
```

### 2.设置属性值

- element.属性	设置内置属性值
- element.setAttribute('属性'，'值');

**区别：**

- element.属性	设置内置属性值
- element.setAttribute('属性', '值');    主要设置自定义的属性(标准)

### 3.移除属性

- element.removeAttribute('属性');

```html
<body>
    <div id="demo" index="1" class="nav"></div>
    <script>
        var div = document.querySelector('div');
    	1.设置元素的属性值
        (1) element.属性 = '值'
        div.id = 'text';
        div.className = 'navs';
        (2) element.setAttribute('属性', '值'); 主要针对于自定义的属性
        div.setAttribute('index', 2);
        div.serAttribute('class', 'footer'); // class特殊 这里写的就是class 不是className
        2.移除属性 removeAttribute('属性');
        div.removeAttribute('index');
    </script>
</body>
```

#### 案列1：tab栏切换布局(重要)

1. Tab栏切换有两个大的模块
2. 上面的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变(排他思想)修改类名的方式)
3. 下面的模块内容，会跟随上面的选项卡变化。所以下面模块变化写到点击事件里面。
4. 规律：下面的模块显示内容和上面的选项卡一一对象，相匹配
5. 核心思路：给上面的tab_list里面的所有li添加自定义属性1，属性值从0开始编号
6. 当我们点击tab_list里面的某个小li，让tab_con里面对象序号的内容显示，其余隐藏(排他思想)

```html
<html>
<head>
<style>
        * {
            padding: 0;
            margin: 0;
        }

        .tab_main {
            margin: 50px auto;
            width: 998px;
            overflow: hidden;
        }

        .tab_list {
            width: 998px;
            height: 39px;
            background-color: #F7F7F7;
            border-bottom: 1px solid #E4393C;
        }

        .tab_list li {
            list-style: none;
            float: left;
            padding: 10px 25px;
            font-size: 14px;
            cursor: pointer;
        }

        /* .tab_list li:hover {
            color: #E4393C;
        } */

        .tab_list .current {
            background-color: #E4393C;
            color: #fff;
        }

        .tab_list button {
            margin-top: 5px;
            float: right;
            height: 28px;
            line-height: 28px;
            padding: 0 16px;
            font-size: 14px;
            color: #fff;
            background-color: #E4393C;
            border: none;
            cursor: pointer;

        }


        .tab_con {
            margin-top: 20px;
            width: 998px;
            height: 200px;
        }

        .item {
            display: none;
        }
    </style>
</head>

<body>
    <div class="tab_main">
        <div class="tab_list">
            <ul>
                <li class="current">商品介绍</li>
                <li>规格与包装</li>
                <li>售后保障</li>
                <li>商品评价(2万+)</li>
                <li>本店好评商品</li>
            </ul>
            <button>加入购物车</button>
        </div>
        <div class="tab_con">
            <div class="item" style="display: block;">商品介绍模块内容</div>
            <div class="item">规格与包装模块内容</div>
            <div class="item">售后保障模块内容</div>
            <div class="item">商品评价(2万+)模块内容</div>
            <div class="item">本店好评商品模块内容</div>
        </div>
    </div>
    <script>
        // 获取元素
        var tab_list = document.querySelector('.tab_list');
        var lis = document.querySelectorAll('li');
        var items = document.querySelectorAll('.item');
        // for循环绑定点击事件
        // 1.上面的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变(排他思想)修改类名的方式)
        for (var i = 0; i < lis.length; i++) {
            lis[i].setAttribute('index', i);
            lis[i].onclick = function () {
                // 干掉其他人 其余的li清除 class 这个类
                for (var i = 0; i < lis.length; i++) {
                    lis[i].className = '';
                }
                // 留下自己
                this.className = 'current';
                // 2.下面的显示内容模块
                var index = this.getAttribute('index');
                console.log(index);
                // 先把所有的模块内容隐藏
                for (var i = 0; i < items.length; i++) {
                    items[i].style.display = 'none';
                }
                // 留下点击li的对应的item 显示出来
                items[index].style.display = 'block';
            }

        }
        var btn = document.querySelector('button');
        btn.onclick = function () {
            alert('加入购物车成功');
        }
    </script>
</body>

</html>
```

### 4.H5自定义属性

**自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。**

自定义属性获取是通过getAttribute('属性') 获取

但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。

H5给我们新增了自定义属性：

#### 1.设置H5自定义属性

H5规定自定义属性data开头做为属性名并且赋值。

比如<div data-index= "1"></div>

或者使用JS设置

element.setAttribute('data-index', 2)

#### 2.获取H5自定义属性

1. 兼容性获取 element.getAttribute('data-index');
2. H5新增element.data.index 或者 element.dataset['index']  ie11才开始支持

```html
<body>
    <div getTime="20" data-index="2" data-list-name="andy"></div>
    <script>
    	var div = document.querySelector('div');
        // console.log(div.getTime); // underfined
        console.log(div.getAttribute('getTime')); // 20
        // 设置一个以data-开头的自定义属性
        div.setAttribute('data-time',20);
        console.log(div.getAttribute('data-index')); // 2
        console.log(div.getAttribute('data-list-name')); // andy
        // h5新增的获取自定义属性的方法 它只能获取data-开头的
        // dataset 是一个集合里面存放了所有以data开头的自定义属性
        console.log(div.dataset);
        console.log(div.dataset.index); // 2
        console.log(div.dataset['index']);// 2
        // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法
        console.log(div.dataset.listName);
        console.log(div.dataset['listName']);
    </script>
</body>
```

```html
<body>
	<div data-key="food" id="fuck"></div>
    <script>
        var myFuck = document.querySelector("#fuck");
        console.log(myFuck.dataset.key);
    </script>
</body>
```



# 5.节点操作

## 5.1 为什么学节点操作

### 获取元素通常使用两种方式;

#### 1.利用DOM提供的方法获取元素

- document.getElementById()
- document.getElementsByTagName()
- document.querySelector()等
- 逻辑性不强、繁琐

------

#### 2.利用节点层级关系获取元素

- 利用父子兄节点关系获取元素
- 逻辑性强，但是兼容性稍差

------

这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单

## 5.2 节点概述

网页中的所有内容都是节点(标签、属性、文本、注释等)，在DOM中，节点使用node来表示

HTML  DOM树中所有节点均可通过JavaScript进行访问，所有HTML元素(节点)均可被修改，也可以创建或删除。

![image-20220124142253012](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220124142253012.png)

一般地，节点至少拥有nodeType(节点类型)、nodeName(节点名称)和nodeValue(节点值)这三个基本属性

- 元素节点 nodeType 为1
- 属性节点 nodeType 为2
- 文本节点 nodeType 为3(文本节点包含文字、空格、换行等)

**我们在实际开发中，节点操作主要操作的是元素节点**

## 5.3 节点层级

利用DOM树可以把节点划分为不同的层级关系，常见的是**父子兄层级关系**。

### 1.父级节点

```javascript
node.parentNode
```

- parentNode属性可返回某节点的父节点，注意是**最近的一个父节点**
- 如果指定的节点没有父节点则返回null

```html
<body>
    <div class="demo">
        <div class="box">
            <span class="erweima"></span>
        </div>
    </div>
    <script>
    	// 1.父节点 parentNode
        var erweima = document.querySelector('.erweima');
        // var box = document.querySelector('.box');
        // 得到的是离元素最近的父级节点
        console.log(erweima.parentNode); // 得到的是class="box"的那个盒子
    </script>
</body>
```

### 2.子节点

#### 1.parentNode.childNodes(标准)

parentNode.childNodes 返回包含指定节点的子节点的集合(伪)，该集合为即时更新的集合。

**注意：返回值里面包含了所以的子节点，包括元素节点，文本节点等。**

**如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNo**des

```html
<body>
    <ul>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
        <li>我是li5</li>
    </ul>
    <script>
    	var ul = document.querySelector('ul');
        for (var i = 0; i < ul.childNodes.length; i++) {
            if (ul.childNodes[i].nodeType == 1) {
                // ul.childNodes[i]是元素节点
                console.log(ul.childNodes[i]);
            }
        }
    </script>
</body>
```

#### 2.parentNode.children(非标准)

parentNode.children是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回(**这个是我们重点掌握的**)。

虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用

```html
<body>
    <ul>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
        <li>我是li5</li>
    </ul>
    <script>
    	var ul = document.querySelector('ul');
        console.log(ul.children);
    </script>
</body>
```

#### 3.parentNode.firstChild 与 parentNode.lastChild

1. firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。
2. lastChild返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。

```html
<body>
    <ol>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
    </ol>
    <script>
    	var ol = document.querySelector('ol');
        // firstChild 第一个子节点 不管是文本节点还是元素节点
        console.log(ol.firstChild); // #text
        // lastChild 最后一个子节点 不管是文本节点还是元素节点
        console.log(ol.lastChild); // #text 
    </script>
</body>
```

#### 4.parentNode.firstElementChild 与 parentNode.lastElementChild

1. firstElementChild  返回第一个子元素节点，找不到则返回null。
2. lastElementChild  返回最后一个子元素节点，找不到则返回null。

注意：这两个方法有兼容性问题，IE9以上才支持

```html
<body>
    <ol>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
    </ol>
    <script>
    	var ol = document.querySelector('ol');
        // firstElementChild 返回第一个子元素节点
        console.log(ol.firstElementChild);
        // lastElementChild 返回最后一个子元素节点
        console.log(ol.lastElementChild);      
    </script>
</body>
```

#### 5.parentNode.children[0]

实际开发中，firstChild和lastChild包含其他节点，操作不方便，而firstElementChild和lastElementChild又有兼容性问题，那么如何获取第一个子元素节点或最后一个子元素节点

1. **如果想要第一个子元素节点，可以使用parentNode.children[0]**

```html
<body>
    <ol>
        <li>我是li1</li>
        <li>我是li2</li>
        <li>我是li3</li>
        <li>我是li4</li>
    </ol>
    <script>
    	var ol = document.quertSelector('ol');
        // 实际开发的写法 既没有兼容性问题又返回第一个子元素
        console.log(ol.children[0]);
        // 因为ol.children得到的是伪，从0开始 ，最后一个元素索引号就是长度减一
        console.log(ol.children[ol.children.length - 1]);
    </script>
</body>
```

##### 案列1：节点操作

1. 导航栏里面的li都要有鼠标经过效果，所以需要循环注册鼠标事件
2. 核心原理：当鼠标经过li里面的 第二个孩子 ul 显示，当鼠标离开，则ul隐藏

```html
<html>
  <head>
<link rel="stylesheet" href="./font_2vhskx4v6vn/iconfont.css">
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        @font-face {
            font-family: "iconfont";
            /* Project id  */
            src: url('iconfont.ttf?t=1643351408962') format('truetype');
        }

        li {
            list-style: none;
        }

        a {
            text-decoration: none;
            color: #000;
            font-size: 12px;
            /* color: #FF8400; */
        }

        .nav_con {
            margin: 50px 100px;

        }

        .nav_con>li {
            float: left;
            text-align: center;
            padding: 20px 0;
            cursor: pointer;
        }

        .nav_con>li>a {
            position: relative;
            /* background-color: pink; */
            padding: 12px 28px 12px 12px;
        }

        .nav_con>li>a:hover {
            color: #FF9900;
            background-color: #EDEEF0;
        }

        .nav_con>li>a::after {
            content: '\e8f2';
            font-family: 'iconfont';
            font-size: 16px;
            color: #FF9900;
            font-style: normal;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            position: absolute;
            top: 12px;
            right: -2px;
        }

        .nav_con>li>ul {
            margin-top: 12px;
            display: none;
        }

        .nav_con>li>ul>li {
            padding: 12px 28px 12px 12px;
            border: 1px solid #FF9900;
            border-top: none;
            font-size: 12px;
        }

        .nav_con>li>ul>li:hover {
            color: #FF9900;
            background-color: #FFF5DA;
        }
    </style>
</head>

<body>
    <ul class="nav_con">
        <li>
            <a href="#">主页</a>
            <ul>
                <li>私信</li>
                <li>评论</li>
                <li>@我</li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>私信</li>
                <li>评论</li>
                <li>@我</li>
            </ul>
        </li>
        <li>
            <a href="#">博客</a>
            <ul>
                <li>私信</li>
                <li>评论</li>
                <li>@我</li>
            </ul>
        </li>
        <li>
            <a href="#">邮箱</a>
            <ul>
                <li>私信</li>
                <li>评论</li>
                <li>@我</li>
            </ul>
        </li>
    </ul>
    <script>
        // 1.获取元素
        var nav = document.querySelector('.nav_con');
        var lis = nav.children; // 得到4个小li
        // 2.循环注册事件
        for (var i = 0; i < lis.length; i++) {
            lis[i].onmouseover = function () {
                this.children[1].style.display = 'block';
            }
            lis[i].onmouseout = function () {
                this.children[1].style.display = 'none';
            }
        }
    </script>
</body>

</html>
```

### 3.兄弟节点

#### 1.node.nextSibling 与 node.previousSibling

nextSibling 返回当前元素的下一个兄弟节点，找不到则返回null。同意，也是包含所有的节点

previousSibling 返回当前元素的上一个兄弟节点，找不到则返回null。同意，也是包含所有的节点

```html
<body>
    <div>我是div</div>
    <span>我是span</span>
    <script>
        var div = document.querySelector('div');
    // 1.node.nextSibling 返回当前元素的下一个兄弟节点。元素节点、文本节点等
    	console.log(div.nextSibling);
    // 2.node.previousSibling 返回当前元素的上一个兄弟节点。元素节点、文本节点等
    	console.log(div.previousSibling);
    </script>
</body>
```



#### 2.node.nextElementSibling 与 node.previousElementSibling

nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。

previousElementSibling 返回放弃元素上一个兄弟节点，找不到则返回null。

> **注意：这两个方法有兼容性问题，IE9以上才支持。**

```html
<body>
    <div>我是div</div>
    <span>我是span</span>
    <script>
    	var span = document.querySelector('span');
        // 1.node.nextElementSibling 返回当前元素下一个兄弟元素节点。
        consloe.log(span.nextElementSibling);
        // 2.node.previousElementSibling 返回当前元素上一个兄弟元素节点
        console.log(span.perviousElementSibling);
    </script>
</body>
```



#### 如何解决兼容性问题

**封装一个兼容性的函数**

```javascript
function getNextElementSibling(element) {
    var el = element;
    while(el = el.nextSibling) {
        if (el.nodeType === 1) {
            return el;
        }
    }
    return null;
}
```

## 5.4 创建节点

我们想要页面添加一个新的元素：

1. 创建元素节点
2. 添加元素节点

### 1.创建节点

```javascript
document.createElement('tagName');
```

document.createElement() 方法创建由tagName 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为**动态创建元素节点**。

### 2.添加节点

```javascript
1.node.appendChild(child) node 父级  child 是子级 后面追加元素 类似于中的push
```

node.appendChild() 方法将一个节点添加到指定父节点的子节点列表**末尾**。类似于CSS里面的after伪元素。

```html
<body>
    <ul></ul>
    <script>
    	// 1.创建节点元素节点
        var lis = document.createElement('li');
        // 2.添加节点 node.appendChild(child) 
        var ul = document.querySelecto('ul');
        ul.appendChild(lis);
    </script>
</body>
```

```javascript
2.node.insertBefore(child, 指定元素)
```

node.insertBefore() 方法将一个节点添加到父节点的指定子节点**前面**。类似于css里面的before伪元素。

```html
<body>
    <ul>
        <li>123</li>
    </ul>
    <script>
        // 3.添加节点 node.insertBefore(child, 指定元素);
        var ul = document.querySelector('ul');
    	var lis = document.createElement('li');
        ul.insertBefore(lis, ul.children[0]);
    </script>
</body>
```

案列1：简单版发布留言案列

1. 核心思路：点击按钮之后，就动态创建一个li，添加到ul里面
2. 创建li的同时，把文本域里面的值通过li.innerHTML赋值给li
3. 如果想要新的留言后面显示就用appendChild如果想要前面显示就用insertBefore

```html
<html>
<head>
<style>
        textarea {
            margin: 50px 100px;
            height: 200px;
            width: 300px;
        }

        button {
            position: absolute;
            top: 230px;
            left: 414px;
            height: 34px;
            width: 60px;
        }
    </style>
</head>

<body>
    <textarea></textarea>
    <button>发布</button>
    <ul>

    </ul>
    <script>
        // 1.获取元素
        var text = document.querySelector('textarea');
        var btn = document.querySelector('button');
        var ul = document.querySelector('ul');
        // 2.注册事件
        btn.onclick = function () {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var lis = document.createElement('li');
                lis.innerHTML = text.value;
                // (2) 添加元素
                // 添加到后面
                // ul.append(lis);
                // 添加到前面
                ul.insertBefore(lis, ul.children[0]);
            }
        }
    </script>
</body>

</html>
```

## 5.5 删除节点

```javascript
node.removeChild(child);
```

```javascript
node.remove(); // 方法可以直接删除指定的元素
```

node.removeChild() 方法从DOM中删除一个子节点，返回删除的节点。

```html
<body>
    <button>删除</button>
    <ul>
        <li>刘德华</li>
        <li>张学友</li>
        <li>郭富城·</li>
        <li>黎明</li>
        <li>周杰伦</li>
    </ul>
    <script>
        // 1.获取元素
        var ul = document.querySelector('ul');
        var btn = document.querySelector('button');
        // 2.删除元素  node.removeChild(child);
        // ul.removeChild(ul.children[0]);
        // 3.点击按钮一次删除里面的孩子
        btn.onclick = function () {
            if (ul.children.length == 0) {
                this.disabled = true;
            } else {
                ul.removeChild(ul.children[0]);
            }
        }
    </script>
</body>
```

### 案列1：删除留言案列

1. 当我们把文本域里面的值赋值给li的时候，多添加一个删除的链接
2. 需要把所有的链接获取过来，当我们点击当前的链接的时候，删除当前链接所在的li
3. 阻止链接跳转需要添加javascript: void(0); 或者javascript:;



```html
<html>
    
<head>
<style>
        textarea {
            margin: 50px 100px;
            height: 200px;
            width: 300px;
        }

        button {
            position: absolute;
            top: 230px;
            left: 414px;
            height: 34px;
            width: 60px;
        }

        li {
            list-style: none;
            width: 300px;
            color: skyblue;
            background-color: hotpink;
            margin: 10px 60px;
        }

        li a {
            float: right;
        }
    </style>
</head>

<body>
    <textarea></textarea>
    <button>发布</button>
    <ul>

    </ul>
    <script>
        // 1.获取元素
        var text = document.querySelector('textarea');
        var btn = document.querySelector('button');
        var ul = document.querySelector('ul');
        // 2.注册事件
        btn.onclick = function () {
            if (text.value == '') {
                alert('您没有输入内容');
                return false;
            } else {
                // console.log(text.value);
                // (1) 创建元素
                var lis = document.createElement('li');
                lis.innerHTML = text.value + "<a href='javascript:;'>删除</a>";
                // (2) 添加元素
                // 添加到后面
                // ul.append(lis);
                // 添加到前面
                ul.insertBefore(lis, ul.children[0]);
                // (3) 删除元素 删除的是当前链接的li 链接的父亲
                var as = document.querySelectorAll('a');
                for (var i = 0; i < as.length; i++) {
                    as[i].onclick = function () {
                        // node.removeChild(child); 删除的是 li 当前a所在的li this.parentNode;
                        ul.removeChild(this.parentNode);
                    }
                }
            }
        }
    </script>
</body>

</html>
```

## 5.6 复制节点(克隆节点)

```javascript
node.cloneNode()
```

node.cloneNode() 方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点

**注意：**

1. 如果括号参数为**空或者为false**，则是**浅拷贝**，即只克隆复制节点本身，不克隆里面的子节点。
2. 如果括号参数为**true**，则是**深度拷贝**，会复制节点本身以及里面所有的子节点
3. 先复制节点，然后再添加节点

```html
<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li> 
    </ul>
    <script>
        // 1.获取元素
    	var ul = document.querySelector('ul');
        // ul.children[0].cloneNode(); // 只会拷贝节点本身
        // 2.拷贝节点
        var lili = ul.children.cloneNode(true);
        // 3.添加节点
        ul.appendChild(lili);
    </script>
</body>
```

## 案列1：动态生成表格

1. 因为里面的学生数据都是动态的，我们需要js动态生成。这里我们模拟数据，自己定义好数据。数据我们采取对象形式存储。
2. 所有的数据都是放到tbody里面的行里面。
3. 因为行很多，我们需要循环创建多个行(对应)
4. 每个行里面又有很多单元格(对应里面的数据)，我们还继续使用循环创建多个单元格，并且把数据存入里面(双重for循环)
5. 最后一列单元格是删除，需要单独创建单元格

```html
<html>
    
<head>

<style>
        table {
            margin: 100px auto;
            width: 500px;
            text-align: center;
            border: 1px solid #333;
            border-collapse: collapse;
        }

        table thead tr {
            height: 30px;
            background-color: #CACDCA;
        }

        table thead tr th {
            border: 1px solid #333;
        }

        table tbody tr {
            height: 28px;

        }

        table tbody tr td {
            border: 1px solid #333;
        }

        a {
            text-decoration: none;
            color: hotpink;
        }
    </style>
</head>

<body>
    <table>
        <thead>
            <tr>
                <th>姓名</th>
                <th>科目</th>
                <th>成绩</th>
                <th>操作</th>
            </tr>
        </thead>
        <tbody>

        </tbody>
    </table>
    <script>
        // 1.先去准备好学生的数据
        var datas = [{
            name: '周杰伦',
            subject: 'JavaScript',
            score: 100
        }, {
            name: '侯佩岑',
            subject: 'JavaScript',
            score: 98
        }, {
            name: '蔡依林',
            subject: 'JavaScript',
            score: '95'
        }, {
            name: '昆凌',
            subject: 'JavaScript',
            score: '88'
        }
        ];
        // 2.往tbody 里面创建行，  有几个人(通过数组的长度) 我们就创建几行
        var tbody = document.querySelector('tbody');
        for (var i = 0; i < datas.length; i++) { // 外面的for循环管行 tr
            // 1.创建行
            var tr = document.createElement('tr');
            // 添加行
            tbody.appendChild(tr);
            // 2.行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数   for循环遍历对象  datas[i]
            for (var k in datas[i]) { // 里面的for循环管列 td
                // 创建单元格
                var td = document.createElement('td');
                td.innerHTML = datas[i][k];
                tr.appendChild(td);
            }
            // 3.创建由删除2个字的单元格
            var tds = document.createElement('td');
            tds.innerHTML = '<a href="javascript:;">删除</a>';
            tr.appendChild(tds);

        }
        // 4.删除操作 
        var as = document.querySelectorAll('a');
        for (var i = 0; i < as.length; i++) {
            as[i].onclick = function () {
                // 点击a 删除 当前a所在行(链接的父元素节点的父元素节点) node.removeChild(child); 
                tbody.removeChild(this.parentNode.parentNode);
            }
        }


        // for (var k in obj) {
        //     k 得到的是属性名
        //     obj[k] 得到的是属性值
        // }
    </script>
</body>

</html>
```

## 5.7 三种动态创建元素区别

- document.write()
- element.innerHTML
- document.createElement()

### 1.document.write()

```html
<body>
    <button></button>
    <p>123</p>
    <script>
    	// 1.document.write() 创建元素 如果页面文档流加载完毕，再调用这句话会导致页面重绘
        var btn = document.querySelector('button')
        btn.onclick = function() {
            document.write('<div>123</div>');
        }
    </script>
</body>
```

### 2.element.innerHTML 拼接字符串效率测试

```html
<body>
    
</body>
<script>
	function fn() {
        var d1 = +new Date();
        var str = '';
        for(var i = 0; i < 1000; i++) {
            document.body.innerHTML += '<div style="width:100px; height:2px; border: 1px solid blue"></div>' + str;
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
</script>
```

### 2.element.innerHTML 数组效率测试

```html
<body>
    
</body>
<script>
	function fn() {
        var d1 = +new Date();
        var array = [];
        for (var i = 0; i <= 1000; i++) {
            array.push('<div style="width: 100px; height =2px; border: 1px solid blue"></div>')
        }
        document.body.innerHTML = array.join('');
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
</script>
```



### 3.document.createElement(tagname)效率测试

```html
<body>
    
</body>
<script>
	function fn() {
        var d1 = +new Date();
        
        for (var i = 0; i < 1000; i++) {
            var div = document.createElement('div');
            div.style.width = '100px';
            div.style.height = '2px';
            div.style.border = '1px solid red';
            document.body.appendChild(div);
        }
        var d2 = +new Date();
        console.log(d2 - d1);
    }
    fn();
</script>
```

### 区别：

1. document.write() 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘
2. innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘
3. innerHTML 创建多个元素效率更高(不要拼接字符串，采取数组形式拼接)，结构稍微复杂
4. createElement() 创建多个元素效率稍低一点点，但是结构更清晰

**总结：不同浏览器下，innerHTML效率(采取数组形式拼接)要比createElement高**

# 6.DOM重点核心

文档对象模型(Document Object Model)是W3C组织推荐的处理可扩展标记语言(HTML或者XML)的标准编程接口。

W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。

1. 对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口。
2. 对于HTML，dom使得html形成一棵dom树，包含文档、元素、节点
3. 我们获取过来的DOM元素是一个对象(object),所以称为 文档对象模型

关于dom操作，我们主要针对于元素的操作，主要有创建、增、删、改、查、属性操作、事件操作。

## 6.1 创建

1. document.write
2. innerHTML
3. createElement

## 6.2 增

1. appendChild
2. insertBefore

## 6.3 删

removeChild

## 6.4 改

主要修改dom的元素属性，dom元素的内容、属性、表单的值等

1. 修改元素属性：src、href、title等
2. 修改普通元素内容：innerHTML、innerText
3. 修改表单元素：value、type、disabled等
4. 修改元素样式：style、className

## 6.5 查

主要获取查询dom的元素

1. DOM提供的API方法：getElementById、getElementsByTagName 古老方法不太推荐
2. H5新增的新方法：querySelector、querySelectoeAll 提倡
3. 利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling)、nextElementSiBling)提倡

## 6.6 属性操作

主要针对于自定义属性

1. getAttribute：得到dom的属性值
2. setAttribute：设置dom的属性值
3. removeAttribute移除属性

6.7 事件操作

给元素注册事件，采取 事件源.事件类型 = 事件处理程序

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动速度     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

# 1.注册事件(绑定事件)

## 1.1 注册事件概述

给元素添加事件，称为**注册事件**或者**绑定事件**。

注册事件有两种方式：**传统方式**和**方法监听注册方式**。

**传统注册方式**

- 利用on开头的事件 onclick
- <button onclick= "alret('hi~')"></button>
- btn.onclick = function() {}
- 特点：注册事件的**唯一性**
- 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数

------

**方法监听注册方式**

- W3C标准 推荐方式
- addEventListener() 他是一个方法
- IE9之前的IE不支持此方法，可使用addachEvent() 代替
- 特点：同一个元素同一个事件可以注册多个监听器
- 按注册顺序依次执行

## 1.2 addEventListener 事件监听方式

```javascript
eventTarget.addEventListener(type, listener[,useCapture])
```

eventTarget.addEventListener() 方法将指定的监听器注册带eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数。

该方法接收三个参数：

- **type：**事件类型字符串，比如click、mouseover，注意这里不要带on
- **listener：**事件处理函数，事件发生时，会调用该监听函数
- **useCapture：**可选参数，是一个布尔值，默认是false，学完DOM事件流后，我们再进一步学习

```html
<body>
    <button>传统方式</button>
    <button>事件侦听注册事件</button>    
    <script>
    	var btns = document.querySelectorAll('button');
        // 1. 传统方式注册事件
        // 点击了第一个按钮，后面的函数会把前面覆盖
        btns[0].onclick = function() {
            alert('hi');
        }
        btn[0].onclick = function() {
            alert('how are you');
        }
        
        
        // 2. 事件侦听注册事件 addEventListener
        // (1) 里面的事件类型是字符串 必定加引号 而且不带on
        // (2) 同一个元素 同一个事件可以添加多个侦听器(事件处理程序)
        btns[1].addEventListener('click', function() {
            alert(22);
        })
        btns[1].addEventListener('click', function() {
            alert(33);
        })
    </script>
</body>
```

## 1.3 attachEvent 事件监听方式

```javascript
eventTarget.attachEvent(eventNameWithOn, callback)
```

eventTarget.attachEvent() 方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，指定的回调函数就会被执行。

该方法接收两个参数：

- **eventNameWithOn：**事件类型字符串，比如onclick、onmouseover，这里要带on
- **callback：**事件处理函数，当目标触发事件时回调函数被调用

**注意：IE9以前的版本支持**

```html
<body>
    <button>IE9版本之前支持的</button>
    <script>
    	var btn = document.querySelector('button');
        // attachEvent ie9以前的版本支持
        btn.attachEvent('onclick', function() {
            alert(11);
        })
    </script>
</body>
```

## 1.4 注册事件兼容性解决方案

```javascript
function addEventListener(element, eventName, fn) {
    // 判断当前浏览器是否支持 addEventListener 方法
    if (element.addEventListener) {
        element.addEventListener(eventName, fn); // 第三个参数 默认是false
    } else if (element.attachEvent) {
        element,attachEvent('on' + eventName, fn);
    } else {
        // 相当于 element.onclick = fn;
        element('on' + eventName) = fn;
    }
}
```

**兼容性处理的原则：首先照顾大多数浏览器，再处理特殊浏览器**

# 2.删除事件(解绑事件)

## 2.1 删除事件的方式

1.传统注册方式

eventTarget.onclick = null;

2.方法监听注册方式

1. eventTarget.removeEventListener(typr, listener[, useCapture]);
2. eventTarget.detachEvent(eventNameWithOn, callback);

```html
<body>
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <script>
    	var divs = document.querySelector('div');
        divs[0].onclick = function () {
            alert(11);
            // 1. 传统方式删除事件
            divs[0].onclick = null;
        }
        
        // 2.removeEventListener 删除事件
        divs[1].addEventListener('click', fn); // 里面的fn 不需要调用加小括号
        function fn() {
            alert(22);
            divs[1].removeEventListener('click', fn);
        }
        
        // 3.ie9以前版本的删除事件
        divs[2].attachEvent('click', fn1);
        function fn1() {
            alert(33);
            divs[2].detachEvent('onclick', fn1);
        }
        
    </script>
</body>
```



## 2.2 删除事件兼容性解决方案

```javascript
function removeEventListener(element, eventName, fn) {
    // 判断当前浏览器是否支持 removeEventListener 方法
    if (element.removeEventListener) {
        element.removeEventListener(eventName, fn); // 第三个参数 默认是false
    } else if (element.detachEvent) {
        element.detachEvent('on' + eventName, fn);
    } else {
        element['on' + eventName] = null;
    }
}
```

# 3.DOM事件流

**事件流**描述的是从页面中接收事件的顺序。

**事件**发生时会在元素节点之间按照特定**的**顺序传播，这个**传播过程**即**DOM事件流**。

比如我们会给一个div注册了点击事件：

DOM事件流分为3个阶段：

1. 捕获阶段
2. 当前目标阶段
3. 冒泡阶段

![image-20220205160902034](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220205160902034.png)

- 事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程。
- 事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程。

我们向水里面扔一块石头，首先他会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素(目标点)的捕获过程；之后会产生泡泡，会在最低点(最具体元素)之后漂浮到水面上，这个过程相当于事件冒泡。

![image-20220205162052144](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220205162052144.png)

**事件**发生时会在元素节点之间按照特定**的**顺序传播，这个**传播过程**即**DOM事件流**。

```html
<html>
	<head>
    <style>
        .father {
            width: 300px;
            height: 300px;
            border: 1px solid #000;
            margin: 100px auto;
        }

        .son {
            width: 200px;
            height: 200px;
            background-color: skyblue;
            margin: 50px auto;
            line-height: 200px;
            text-align: center;
        }
    </style>
    </head>
    <body>
        <div class="father">
            <div class="son">son盒子</div>
        </div>
        <script>
        	// dom 事件流 三个阶段
            // 1.JS代码中只能执行捕获或者冒泡其中的一个阶段。
            // 2.onclick 和 attachEvent(ie) 只能得到冒泡阶段。
            // 3.捕获阶段 如果addEventListener 第三个参数是 true 那么处于捕获阶段 document -> html -> body -> father -> son
            var son = document.querySelector('.son');
            son.addEventListener('click', function() {
                alert('son');
            }, true);
            var father = document.querySelector('.father');
            father.addEventListener('click', function() {
                alert('father');
            }, true);
            // 4.冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么处于冒泡阶段 son -> father -> body -> html -> document
            var son = document.querySelector('.son');
            son.addEventListener('click', function() {
                alert('son');
            }, false);
            var father = document.querySelector('.father');
            father.addEventListener('click', function() {
                alert('father');
            }, false);
            document.addEventListener('click', function() {
                alert('documnet');
            })
        </script>
    </body>
</html>
```

**注意**：

1. JS代码中只能执行捕获或者冒泡其中的一个阶段。
2. onclick 和 attachEvent 只能得到冒泡阶段。
3. addEventListener(type, listener[, useCapture])第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false(不写默认就是false)，表示在事件冒泡阶段调用事件处理程序。
4. **实际开发中我们很少使用事件捕获，我们更关注事件冒泡。**
5. **有些事件是没有看到的，比如onblur、onfocus、onmouseenter、onmouseleave**
6. **事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。**

# 4.事件对象

## 4.1 什么是事件对象

```javascript
eventTarget.onclick = function(event) {}
eventTarget.addEventListener('click', function(event) {})
// 这个event就是事件对象，我们还喜欢写成e 或者evt
```

官方解释：event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。

简单理解：事件发生后，**跟事件相关的一系列信息数据的集合**都放到这个对象里面，这个对象就是**事件对象event**，它有很多属性和方法。

比如：

1. 谁绑定了这个事件
2. 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
3. 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。

## 4.2 事件对象的使用语法

```javascript
eventTarget.onclick = function(event) {
    // 这个event就是事件对象，我们还喜欢的写成e 或者evt
}
eventTarget.addEventLisstener('click', function(event) {
    // 这个event就是事件对象，我们还喜欢写成e 或者evt
})
```

这个event是个形参，系统帮我们设定为事件对象，不需要传递实参过去。

当我们注册事件时，event对象就会被系统自动创建，并依次传递给事件监听器(事件处理函数)

## 4.3 事件对象的兼容性方案

事件对象本身的获取存在兼容问题：

1. 标准浏览器中是浏览器给方法传递的参数，只需要定义形参e就可以获取到。
2. 在IE6—8中，浏览器不会给方法传递参数，如果需要的话，需要到windows.event中获取查找。

解决方案：

e = e || windows.event;

例：

```html
<body>
    <div>你好呀</div>
    <script>
    	var div = document.querySelector('div');
        div.addEventListener('click', function(e) {
            e = e || windows.event;
            console.log(e);
        })
    </script>
</body>
```

## 4.4 事件对象的常见属性和方法

| 事件对象属性方法    | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| e.target            | 返回**触发**事件的对象   标准                                |
| e.srcElement        | 返回**触发**事件的对象   非标准  ie6-8使用                   |
| e.type              | 返回事件的类型   比如click  mouseover   不带on               |
| e.canceBubble       | 该属性阻止冒泡   非标准   ie6-8使用                          |
| e.returnValue       | 该属性  阻止默认事件(默认行为)  非标准  ie6-8使用  比如不让链接跳转 |
| e.preventDefault()  | 该方法  阻止默认事件(默认行为)  标准  比如不让链接跳转       |
| e.stopPropagation() | 阻止冒泡  标准                                               |

### 1.e.target  与 e.srcElement

e.target  返回触发事件的对象(标准)

e.scrElement 返回触发事件的对象(非标准) ie6-8使用

```html
<html>
    
<head>
<style>
        div {
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>

</head>

<body>
    <div>王老吉</div>
    <ul>
        <li>abc</li>
        <li>123</li>
        <li>456</li>
    </ul>
    <script>
        // 常见事件对象的属性和方法
        // 1.e.target 返回的是触发事件的对象(元素)  this 返回的是绑定(注册)事件的对象(元素)
        // 区别：e.target 点击了那个元素，就返回那个元素 this 那个元素绑定了这个点击事件，那么就返回谁
        var divs = document.querySelector('div');
        divs.addEventListener('click', function (e) {
            console.log(e.target);
            console.log(this);
        });

        var ul = document.querySelector('ul');
        ul.addEventListener('click', function (e) {
            // 我们给ul 绑定了事件  那么this 就指向的目标函数ul
            console.log(this);
            // e.target 指向我们点击的那个对象 谁触发了这个事件 我们点击的是li e.target指向的就是li
            console.log(e.target);

        });

        // 了解兼容性
        // div.onclick = function(e) {
        //     e = e || window.event;
        //     var target = e.target || e.srcElement;
        //     console.log(target);
        // }

        // 2.了解 跟 this 有个非常相似的属性 currentTarget 指定的是谁绑定了这个事件
    </script>
</body>

</html>
```

### 2.e.type 返回事件的类型

```html
<html>
    
<head>
<style>
        div {
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>

</head>

<body>
    <div>王老吉</div>
    <a href="http://www.baidu.com">百度</a>
    <form action="http://www.baidu.com">
        <input type="submit" value="提交" name="sub">
    </form>
    <script>
        // 返回事件类型
        var div = document.querySelector('div');
        div.addEventListener('click', fn);
        div.addEventListener('mouseover', fn);
        div.addEventListener('mouseout', fn);
        function fn(e) {
            console.log(e.type);
        }
    </script>
</body>


</html>
```

### 3.e.preventDefault() 与 e.returnValue

e.preventDefault() 该方法  阻止默认事件(默认行为)  标准  比如不让链接跳转

e.returnValue 该属性  阻止默认事件(默认行为)  非标准  ie6-8使用  比如不让链接跳转

```html
<html>
    
<head>
<style>
        div {
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>

</head>

<body>
    <div>王老吉</div>
    <a href="http://www.baidu.com">百度</a>
    <form action="http://www.baidu.com">
        <input type="submit" value="提交" name="sub">
    </form>
    <script>
        // 1.阻止默认行为(事件) 让链接不跳转 或者让提交按钮不提交
        var a = document.querySelector('a');
        a.addEventListener('click', function (e) {
            e.preventDefault(); // dom 标准写法
        });
        // 2.传统的注册方法
        a.onclick = function () {
            // 普通浏览器 e.preventDefault(); // 方法
            e.preventDefault();

            // 低版本浏览器 ie678 returnValue 属性
            e.returnValue;

            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 特点：return 后面的代码不执行了，
            // 而且只限于传统的注册方式
            return false;
            // alert(11); 这句代码不会执行了
        }
    </script>
</body>


</html>
```

# 5.阻止事件冒泡

## 5.1 阻止事件冒泡的两种方式

事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点。

事件冒泡本身的特性：会带来的坏处，也会带来的好处，需要我们灵活掌握。

**阻止事件冒泡**

- 标准写法：利用事件对象里面的stopPropagation() 方法

```javascript
e.stopPropagation()
```

- 非标准写法：IE 6-8 利用事件对象 cancelBubble属性

```javascript
e.cancelBubble = true;
```

```html
<html>
    
<head>
<style>
        .father {
            width: 200px;
            height: 200px;
            border: 1px solid skyblue;
            margin: 100px auto;
        }

        .son {
            width: 150px;
            height: 150px;
            background-color: pink;
            margin: 25px 25px;
            line-height: 150px;
            text-align: center;
        }
    </style>

</head>

<body>
    <div class="father">
        <div class="son">son盒子</div>
    </div>
    <script>
        // 阻止冒泡  dom推荐的标准 stopPropagation()
        var son = document.querySelector('div');
        son.addEventListener('click', function (e) {
            alert('son');
            e.stopPropagation(); // stop停止 propagation传播
            e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡

        });
        son.parentElement.addEventListener('click', function () {
            e.stopPropagation();
            alert('father');

        });
        son.parentElement.parentElement.addEventListener('click', function () {
            e.stopPropagation();
            alert('body');

        });
    </script>
</body>


</html>
```

# 6.事件委托(代理、委派)

事件冒泡本身的特性，会带来的坏处，也会**带来的好处**，需要我们灵活掌握。生活中有如下场景：

![image-20220206200542244](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220206200542244.png)

事件冒泡本身的特性，会带来的坏处，也会**带来的好处**，需要我们灵活掌握。程序中也有如此场景：

```html
<ul>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
    <li>知否知否，应该有弹框在手</li>
</ul>
```

点击每个li都会弹出对话框，以前需要给每个li注册事件，是非常辛苦的，而且访问DOM的次数越多，这就会延长整个页面的交互就绪时间。

以上案列：给ul注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击li，事件会冒泡到ul上，ul有注册事件，就会触发事件监听器。

```html
body>
    <ul>
        <li>知否知否,应该有弹框在手</li>
        <li>知否知否,应该有弹框在手</li>
        <li>知否知否,应该有弹框在手</li>
        <li>知否知否,应该有弹框在手</li>
        <li>知否知否,应该有弹框在手</li>
    </ul>
    <script>
        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
        var ul = document.querySelector('ul');
        ul.addEventListener('click', function (e) {
            // 排他思想 先用循环把ul里面的所有的li的背景色先清除掉
            for (var i = 0; i < ul.children.length; i++) {
                ul.children[i].style.backgroundColor = '';
            }
            // e.target 这个可以得到我们点击的对象
            e.target.style.backgroundColor = 'hotpink';
        })
    </script>
</body>


</html>
```

**事件委托**

事件委托也称为事件代理，在jQuery里面称为事件委派。

**事件委托的原理：**

> **不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。**

**事件委托的作用**

我们只操作了一次DOM，提高了程序的性能。

# 7.常用的鼠标事件

## 7.1 常用的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

### 1.禁止鼠标右键菜单

contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```javascript
document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
});
```

### 2.禁止鼠标选中(selectstart  开始选中)

```javascript
document.addEventListener('selectstart', function(e) {
    e.preventDefault();
});
```

```html
<body>
    <p>我是一段不愿意分享的文字</p>
    <script>
        // 1.contextmenu 禁用右键菜单
        document.addEventListener('contextmenu', function (e) {
            e.preventDefault();
        })
        // 2.selectstart 禁止选中文字
        document.addEventListener('selectstart', function (e) {
            e.preventDefault();
        })
    </script>
</body>
```

## 7.2 鼠标事件对象

**event**对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要用鼠标事件对象**MouseEvent** 和键盘事件对象 **KeyboardEvent。**

| 鼠标事件对象 | 说明                                   |
| ------------ | -------------------------------------- |
| e.clientX    | 返回鼠标相对于浏览器窗口可视区的X坐标  |
| e.clientY    | 返回鼠标相对于浏览器窗口可视区的Y坐标  |
| e.pageX      | 返回鼠标相对于文档页面的X坐标 IE9+支持 |
| e.pageY      | 返回鼠标相对于文档页面的Y坐标 IE9+支持 |
| e.screenX    | 返回鼠标相对于电脑屏幕的X坐标          |
| e.screenY    | 返回鼠标相对于电脑屏幕的Y坐标          |

![image-20220206214957680](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220206214957680.png)

```html
<script>
        // 鼠标事件对象 MouseEvent
        document.addEventListener('click', function (e) {
            // 1.client 鼠标在可视区的x和y坐标
            console.log(e.clientX);
            console.log(e.clientY);
            console.log('-------------------');

            // 2.page 鼠标在页面文档的x和y坐标
            console.log(e.pageX);
            console.log(e.pageY);
            console.log('-------------------');

            // 3.screen 鼠标在电脑屏幕的x和y坐标
            console.log(e.screenX);
            console.log(e.screenY);
        })
    </script>
```

案列1：跟随鼠标的图片

这个图片一直跟随鼠标移动

1. 鼠标不断的移动，使用鼠标移动事件: mousemove
2. 在页面中移动，给document注册事件
3. 图片要移动距离，而且不占位置，我们使用绝对定位即可
4. 核心原理：每次鼠标移动，我们都会获得最新的鼠标坐标，把这个x和y做为图片的top和left值就可以移动图片

```html
<html>
    
<head>
<style>
        img {
            position: absolute;
            width: 200px;
        }
    </style>

</head>

<body>
    <img src="./images/angel.gif" alt="">
    <script>
        // 1.mousemove 只要我们鼠标移动1px 就会触发这个事件
        // console.log(1);
        // 2.核心原理: 每次鼠标移动，我们都会获得最新的鼠标坐标，把这个x和y坐标做为图片的top和left值 就可以移动图片
        var pic = document.querySelector('img');
        document.addEventListener('mousemove', function (e) {

            var x = e.pageX;
            var y = e.pageY;
            console.log('x的坐标是' + x, 'y的坐标是' + y);
            // 3.千万不要忘记给left和top 添加px 单位
            pic.style.left = x - 100 + 'px';
            pic.style.top = y - 66.5 + 'px';
        })

    </script>
</body>


</html>
```

# 8.常用的键盘事件

## 8.1 常用键盘事件

事件除了使用鼠标触发，还可以使用键盘触发。

| 键盘事件   | 触发条件                                                     |
| ---------- | ------------------------------------------------------------ |
| onkeyup    | 某个键盘按键被松开时触发                                     |
| onkeydown  | 某个键盘按键被按下时触发                                     |
| onkeypress | 某个键盘按键被按下时触发  **但是它不识别功能键 比如 ctrl shift 箭头等** |

**注意：**

1. **如果使用addEventListener不需要加on**
2. **onkeypress和前面2个的区别是，它不识别功能键，比如左右箭头、shift、crtl等**
3. **三个事件的执行顺序是：keydown -- keypress -- keyup**

```javascript
1.keyup 按键弹起的时候触发
// document.onkeyup = function() {
//    console.log('我弹起了');
// }

document.addEventListener('keyup', function() {
	console.log('我弹起了');
})

2.keydown 按键按下的时候触发 能识别功能键
document.addEventListener('keydown', function() {
    console.log('我按下了down');
})

3.keypress 按键按下的时候触发 不能识别功能键 如ctrl、shift、方向键等。
document.addEventListener('keypress', function() {
    console.log('我按下了press');
})
// 4.三个事件的执行顺序 keydown -- keypress -- keyup
```

## 8.2 键盘事件对象

| 键盘事件对象 属性 | 说明                  |
| ----------------- | --------------------- |
| keyCode           | 返回**该**键的ASCII值 |
| key               | 返回该键              |

**注意：onkeydown和onkeyup的keyCode属性不区分字母大小写，onkeypress的keyCode属性区分字母大小写。**

**在我们实际开发中，我们更多的使用keydown和keyup，它能识别所有的键(包括功能键)**

**keypress不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值 例如 a 返回 97 ， A返回的ASCII值是65**

```javascript
// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值
// 1.我们的keyup 和keydown事件不区分字母大小写 a和A得到的都是65
// 2.我们的keypress 事件 区分字母大小写 a 得到的是97 A得到的是65
// 3.key属性 返回该键 区分大小写
document.addEventListener('keyup', function(e) {
    console.log(e.keyCode); // 返回该键的ASCII码值
    console.log(e.key); // 返回该键 识别功能键 区分大小写
})
document.addEventListener('keypress', function(e) {
    console.log(e.keyCode);
    console.log(e.key); // 返回该键 不识别功能键 区分大小写
})


```

## 8.3 ASCII表

![image-20220207115445444](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220207115445444.png)

## 案列1：模拟京东按键输入内容

当我们按下s键，光标就定位到搜索框。

1. 核心思路：检测用户是否按下了s键，如果按下s键，就把光标定位到搜索框里面
2. 使用键盘事件对象里面的keyCode 判断用户按下的是否是s键
3. 搜索框获得焦点；使用js里面的**focus()** 方法

```html
<html>
    
<head>
<style>
        input {
            outline: none;
        }
    </style>
</head>

<body>
    <input type="text">
    <script>
        var search = document.querySelector('input');
        // 这里用keyup 按键弹起的时候触发  keydown是按键按下的时候触发
        // document.addEventListener('keyup', function (e) {
        //     if (e.key === 's') {
        //         search.focus();
        //     }
        // })

        document.addEventListener('keyup', function (e) {
            if (e.keyCode === 83) {
                search.focus();
            }
        })
    </script>
</body>

</html>
```

## 案列2：模拟京东快递单号查询

当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。

1. 快递单号输入内容时，上面的大号字体盒子(con)显示(这里面的字号更大)
2. 表单检测用户输入：给表单添加键盘事件
3. 同时把快递单号里面的值(value)获取过来赋值给con盒子(innerText)做为内容
4. 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子
5. **注意：keydown和keypress在文本框里面的特点：他们两个事件触发的时候，文字还没有落入文本框中。**
6. **keyup事件触发的时候，文字已经落入文本框里面了**
7. 当我们失去焦点，就隐藏这个con盒子
8. 当我们获得焦点，并且文本框内容不为空，就显示这个con盒子

```html
 <html>
     
<head>
<style>
        * {
            padding: 0;
            margin: 0;
        }

        body {
            background-color: #FAFAFA;
        }


        .search {
            margin: 100px 100px;
            position: relative;

        }

        .con {
            width: 186px;
            height: 20px;
            padding: 5px 0;
            position: absolute;
            top: -42px;
            left: 0;
            border-collapse: collapse;
            box-shadow: 0 2px 7px rgb(0 0 0 / 20%);
            font-size: 18px;
            line-height: 20px;
            display: none;

        }

        .con::before {
            content: '';
            width: 0;
            height: 0;
            position: absolute;
            bottom: -16px;
            left: 25px;
            border: 8px solid #fff;
            border-left: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 8px solid transparent;
        }

        .jd {
            outline: none;
            width: 178px;
            height: 24px;
            padding: 0 4px;
            border: 1px solid #000;
            border-collapse: collapse;
        }
    </style>
</head>

<body>
    <div class="search">
        <div class="con"></div>
        <input type="text" placeholder="请输入您的快递单号" class="jd">
    </div>
    <script>
        var con = document.querySelector('.con')
        var jd_input = document.querySelector('.jd');
        jd_input.addEventListener('keyup', function () {
            // console.log(11);
            if (this.value == '') {
                con.style.display = 'none';
            } else {
                con.style.display = 'block';
                con.innerHTML = this.value;
            }
        })
        // 当我们失去焦点，就隐藏这个con盒子
        jd_input.addEventListener('blur', function () {
            con.style.display = 'none';
        })
        // 当我们获得焦点，就显示这个con盒子
        jd_input.addEventListener('focus', function () {
            if (this.value != '') {
                con.style.display = 'block';
            }
        })
    </script>
</body>

</html>
```

# 1.BOM概述

## 1.1 什么是BOM

BOM(Browser Object Model)即**浏览器对象模型**，它提供了独立于内容而与**浏览器窗口进行交互的对象**，其核心对象是window。

BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。

BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分

**DOM**

- 文档对象模型
- DOM就是把[**文档**]当做一个[**对象**]来看待
- DOM的顶级对象是**document**
- DOM主要学习的是操作页面元素
- DOM是W3C标准规范

------

**BOM**

- 浏览器对象模型
- 把[**浏览器**]当做一个[**对象**]来看待
- BOM的顶级对象是**window**
- BOM学习的是浏览器窗口交互的一些对象
- BOM是浏览器厂商在各自浏览器上定义的，兼容性较差

## 1.2 BOM的构成

BOM比DOM更大，它包含DOM。

![image-20220208110513057](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220208110513057.png)

**window对象是浏览器的顶级对象**，它具有双重角色。

1. 它是JS访问浏览器窗口的一个接口。
2. 它是一个全局对象，定义在全局作用域中的变量，函数都会变成window对象的属性和方法。

在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如alert()、prompt()等。

**注意：window下的一个特殊属性window.name**

```javascript
var num = 10;
console.log(num); // 10
console.log(window.num); // 10

function fn() {
    console.log(11);
}
fn(); // 11
window.fn(); // 11

alert(11);
window.alert(11);
```

# 2.window对象的常见事件

## 2.1 窗口加载事件

### 1.onload

> window.onload = function() {}
>
> 或者
>
> window.addEventListener('load', function() {});

window.onload是窗口(页面)加载事件，当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS文件等)，就调用的处理函数。

**注意：**

1. 有了window.onload就可以把JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数。
2. window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。
3. 如果使用addEventListener则没有限制

### 2.DOMContentLoaded

> document.addEventListener('DOMContentLoaded', function() {})

DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。

ie9以上支持

如果页面的图片很多的话，从用户访问到onload触发可能需要较长事件，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适。

```html
<html>
    
<head>
<script>
        // 1.传统注册事件只能写一次
        // window.onload = function () {
        //     var btn = document.querySelector('button');
        //    btn.onclick = function() {
        //        alert(11);
        //    }

        // }

        window.addEventListener('load', function () {
            var btn = document.querySelector('button');
            btn.addEventListener('click', function () {
                alert(11);
            })

        })
        window.addEventListener('load', function () {
            alert(22);
        })
        document.addEventListener('DOMContentLoaded', function() {
            alert(33);
        })
        // load 等页面内容全部加载完毕，包含页面dom元素 图片 falsh css等等
        // DOMContentLoaded 是DOM加载完毕 ，不包含图片 falsh css等就可以执行 加载速度比load更快
    </script>
</head>

<body>
    <button>按钮</button>
</body>

</html>
```

## 2.2 调整窗口大小事件

> window.onresize = function() {}
>
> 或者
>
> window.addEventListener('resize', function() {});

window.onresize 是调整窗口大小加载事件，当触发时就调用的处理函数。

**注意：**

1. 只要窗口大小发生像素变化，就会触发这个事件。
2. 我们经常利用这个事件完成响应式布局。window.innerWidth当前屏幕的宽度。

```html
<html>
    
<head>
<style>
        div {
            width: 200px;
            height: 200px;
            background-color: hotpink;
        }
    </style>
    <script>
        window.addEventListener('load', function () {
            var div = document.querySelector('div');
            window.addEventListener('resize', function () {
                console.log(window.innerWidth);
                if (window.innerWidth <= 800) {
                    div.style.display = 'none';
                } else {
                    div.style.display = 'block';
                }
            })
        })
    </script>
</head>

<body>
    <div></div>

</body>

</html>
```

这个时候就需要防抖，无论我们怎么拖动窗口大小，只执行一次获取浏览器宽高的方法

```js
const debounce = (fn, delay) => {
	let timer;
	return function() {
		if (timer) {
			clearTimeout(timer);
		}
		timer = setTimeout(() => {
			fn();
		}, delay);
	}
};
const cancalDebounce = debounce(getWindowInfo, 500);

window.addEventListener('resize', cancalDebounce);
```

现在就可以了，该方法只会在窗口停止变化的 500 毫秒后触发一次

**友情提示**：如果是在 vue 中使用的话，记得在组件销毁的钩子中去移除监听事件，不然可能会出现一些你意想不到的 bug

```js
window.removeEventListener('resize', cancalDebounce);
```



# 3.定时器

## 3.1 两种定时器

window对象给我们提供了2个非常好用的方法-**定时器。**

- setTimeout()
- setInterval()

### 1.setTimeout() 定时器

> window.setTimeout(调用函数，延迟的毫秒数)；

setTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。

**注意：**

1. window可以省略。
2. 这个调用函数可以**直接写函数，或者写函数名**或者采取字符串'函数名()'三种形式。第三种不推荐。
3. 延迟的毫秒数省略默认是0，如果写，必须是毫秒。
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。

```javascript
		// 1.直接写函数
        // setTimeout(function () {
        //     console.log('爆炸啦 快跑');
        // }, 5000)

        // 2.写函数名
        // function callback() {
        //     console.log('记住好好敲代码哦');
        // }
        // setTimeout(callback, 2000)

        // 3.'函数名()'
        function callback() {
            console.log(11);
        }
        setTimeout('callback()', 2000);
// 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。
var timer1 = setTimeout(callback, 2000);
var timer2 = setTimeout(callback, 5000);
```

setTimeout() 这个调用函数我们也称为**回调函数callback**

普通函数是按照代码顺序直接调用。

而这个函数，**需要等待**时间，时间到了才去调用这个函数，因此称为回调函数。

简单理解：回调，就是回头调用的意思。上一件事干完，再**回**头再**调**用这个函数。

以前我们讲的element.onclick = function() {} 或者 element.addEventListener('click', fn) 里面的函数也是回调函数。

### 案列1：5秒后自动关闭的广告

1. 核心思路：5秒之后，就把这个广告隐藏起来
2. 用定时器setTimeout

```html
<html>
    
<head>
<style>
        .ad {
            width: 750px;
            margin: 0 393px;
        }
    </style>
    <script>
        window.addEventListener('load', function () {
            var ad = document.querySelector('img');
            setTimeout(function () {
                ad.style.display = 'none';
            }, 5000)
        })


    </script>
</head>

<body>
    <img src="./images/ad.png" alt="" class="ad">
</body>

</html>
```

## 3.2 停止setTimeout()定时器

> window.clearTimeout(timeoutID)

clearTimeout()方法取消了先前通过调用setTimeout() 建立的定时器。

**注意：**

1. window可以省略。
2. 里面的参数就是定时器的标识符

```html
<body>
    <button>停止定时器</button>
    <script>
        var btn = document.querySelector('button');
        var timer = setTimeout(function () {
            console.log('爆炸啦')
        }, 5000)
        btn.addEventListener('click', function () {
            clearTimeout(timer)
            console.log('你得救啦');
        })
    </script>
</body>
```

## 3.3 setInterval() 定时器

> window.setInterval(回调函数，间隔的毫秒数);

setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。

**注意：**

1. window可以省略。
2. 这个调用函数可以**直接写函数，或者写函数名**或者采取字符串'函数名()'三种形式。第三种不推荐。
3. 间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。
4. 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。

```javascript
// window.setInterval(调用函数，间隔时间)
    setInterval(function () {
        console.log(11);
    }, 1000)
    // setTimeout 延时时间到了，就去调用这个回调函数，只调用一次就结束了
    // setInterval 间隔这个时间，就去调用这个回调函数，会调用很多次。重复调用这个函数
```

### 案列1：京东倒计时案例

1. 这个倒计时是不断变化的，因此需要定时器来自动变化(setInterval)
2. 三个黑色盒子里面分别存放时分秒
3. 三个黑色盒子利用innerHTML放入计算的小时分钟秒数
4. 第一次执行也是间隔毫秒数，因此刚刷新页面会有空白
5. 最好采取封装函数的方式，这样可以先调用一次这个函数，防止刚开始刷新页面有空白问题

```html
<html>
    
<head> 
<style>
        div {
            margin: 100px 100px;
        }

        .hour,
        .minute,
        .second {
            display: inline-block;
            width: 40px;
            height: 40px;
            background-color: #000;
            color: hotpink;
            font-size: 24px;
            text-align: center;
            line-height: 40px;
        }
    </style>
    <script>
        window.addEventListener('load', function () {
            // 1.获取元素
            var hour = document.querySelector('.hour'); // 小时的黑色盒子
            var minute = document.querySelector('.minute'); // 分钟的黑色盒子
            var second = document.querySelector('.second'); // 秒数的黑色盒子
            var inputTime = +new Date('2022-2-08 23:00:00'); // 返回的是用户输入时间总的毫秒数
            countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 但要放在输入时间的下面
            function countDown() {
                var nowTime = +new Date(); // 返回的是当前时间总的毫秒数               
                var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数
                var h = parseInt(times / 60 / 60 % 24);
                h = h < 10 ? '0' + h : h;
                hour.innerHTML = h; // 把剩余的小时给 小时的盒子
                var m = parseInt(times / 60 % 60);
                m = m < 10 ? '0' + m : m;
                minute.innerHTML = m; // 把剩余的分钟给 分钟的盒子
                var s = parseInt(times % 60);
                s = s < 10 ? '0' + s : s;
                second.innerHTML = s; // 把剩余的秒数给 秒数的盒子
            }
            setInterval(countDown, 1000);
        })
    </script>
</head>

<body>
    <div>
        <span class="hour">11</span>
        <span class="minute">22</span>
        <span class="second">33</span>
    </div>

</body>

</html>
```

## 3.4 停止setInterval() 定时器

> window.clearInterval(intervalID);

clearInterval() 方法取消了先前通过调用setInterval() 建立的定时器。

**注意：**

1. window可以省略
2. 里面的参数就是定时器的标识符

```html
<body>
    <button class="begin">开启定时器</button>
    <button class="stop">关闭定时器</button>
    <script>
        var begin = document.querySelector('.begin');
        var stop = document.querySelector('.stop');
        var timer = null; // 全局变量 null是一个空对象
        begin.addEventListener('click', function () {
            timer = setInterval(function () {
                console.log('开始啦');
            }, 1000)
        });
        stop.addEventListener('click', function () {
            clearInterval(timer);
        })
    </script>
</body>
```

### 案列1：发送短信

点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信

![image-20220209121337625](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220209121337625.png)

1. 按钮点击之后，会禁用disabled为true
2. 同时按钮里面的内容会变化，注意button里面的内容通过innerHTML修改
3. 里面秒数是有变化的，因此需要用到定时器。
4. 定义一个变量，在定时器里面，不断递减
5. 如果变量为0说明到了时间，我们需要停止定时器，并且复原按钮初始状态

```html
<html>
    
<head>
<style>
        input {
            outline: none;
            height: 20px;
        }

        button {
            margin-left: 5px;
        }
    </style>
</head>

<body>
    手机号: <input type="number"><button>发送</button>
    <script>

        var btn = document.querySelector('button');
        var times = 3; // 定义剩下的秒数
        btn.addEventListener('click', function () {
            btn.disabled = true;
            var timer = setInterval(function () {
                if (times == 0) {
                    // 清除定时器和复原按钮
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.innerHTML = '发送';
                    times = 3; // 这个3需要从新开始
                } else {
                    btn.innerHTML = '还剩' + times + '秒';
                    times--;
                }
            }, 1000)
        })
    </script>
</body>

</html>
```

## 3.5 this指向问题

this的指向在函数定义的时候确定不了的，只有函数执行的时候才能确定this到底指向谁，**一般情况下this的最终指向的是那个调用它的对象**

### 1.全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window)

```javascript
console.log(this); // this指向的是window

function fn() {
    console.log(this);
}
fn(); // this指向的是window 因为window.fn()调用函数 但是window可以省略不写

setTimeout(function() {
    console.log(this); // this指向的是window 因为定时器也是window.setTimeout()
}, 1000)
```

### 2.方法调用中谁调用this 就指向谁

```javascript
var o ={
    sayHi: function() {
        console,log(this); // this指向的是 o 这个对象
    }
}
o.sayHi();
```

```html
<body>
    <button>按钮</button>
    <script>
    	var btn = document.querySelector('button');
        // btn.onclick = function() {
        //   console.log(this); // this指向的是btn这个按钮对象
        // }
        
        btn.addEventListener('click', function() {
            console.log(this); // this指向的是btn这个按钮对象
        })
        
    </script>
</body>
```

### 3.构造函数中this指向构造函数的实例

```javascript
function Fun() {
    console.log(this); // this指向的是fun 实例对象
}
var fun = new Fun();
```

# 4.JS执行机制

## 4.1 JS是单线程

JavaScript语言的一大特点就是**单线程**，也就是说，**同一个时间只能做一件事**这是因为avaScript这门脚本语言诞生的使命所致------JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的，比如我们对某个DOM元素进行添加和删除操作，不能同时进行，应该先进行添加，之后再删除。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务，这样所导致的问题是   ：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

## 4.2 同步和异步

为了解决这个问题。利用多核CPU的计算能力，HTML5提出Web Worker 标准，允许JavaScript脚本创建多个线程，于是，JS出现了**同步**和**异步**。

**同步**

前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了(10分钟之后)，再去切菜，炒菜。

**异步**

你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情，比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

```javascript
console.log(1);

        setTimeout(function () {
            console.log(3);
        })

        console.log(2);
```

**他们的本质区别：这条流水线上各个流程的执行顺序不同。**

**同步任务**

同步任务都在主线程上执行，形成一个**执行栈**。

JS的异步是通过回调函数实现的。

一般而言，异步任务有以下三种类型。

1. 普通事件，如click，resize等
2. 资源加载，如load、error等
3. 定时器，包括setTimeout，setInterval等

异步任务相关**回调函数**添加到**任务队列**中(任务队列也称为消息队列)

```javascript
console.log(1);

setTimeout (function() {
    console.log(3)
}, 0)

console.log(2);
```

![image-20220209223111984](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220209223111984.png)



![image-20220209222947656](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220209222947656.png)

## 4.3 JS执行机制

1. 先执行**执行栈中的同步任务**。
2. 异步任务(回调函数)放入任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取**任务队列**中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。

![image-20220209223907038](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220209223907038.png)

```javascript
console.log(1);
document.onclick = function() {
    console.log('click')
};
console.log(2);
setTimeout(function() {
    console.log(3)
}, 3000);

// 由于JS执行机制 
如果不点击，就不会触发点击事件，也不进入异步进程处理 也就不会执行 执行顺序就是1 2 3
如果点击了，如果在3秒前点击 执行顺序就是 1 2 'click' 3 如果在3秒后点击 执行顺序就是 1 2 3 'click'
```

![image-20220209224734312](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220209224734312.png)



![image-20220209225435552](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220209225435552.png)

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为**事件循环(event loop)**

# 5.location 对象

## 5.1 什么是location对象

window对象给我们提供了一个**location属性**用于**获取或设置窗体的URL**，并且可以用于**解析URL**，因为这个属性返回的是一个对象，所以我们也将这个属性也称为**location对象。**

## 5.2 URL

**统一资源定位符(Uniform Resource Locator, URL)**是互联网上标准资源的地址。互联网上的每个文件都有唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

URL 的一般语法格式为：

> protocol: //host[:port]/path/[?query]#fragment
>
> 例：http://www.itcast.cn/index.html?name=andy&age=18#link

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocol | 通信协议 常用的http，ftp，maito等                            |
| host     | 主机(域名)  www.itheima.com                                  |
| port     | 端口号 可选，省略时使用方案的默认端口 如http的默认端口为80   |
| path     | 路径 由 零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数 以键值对的形式，通过&符号分隔开来                       |
| fragment | 片段 #后面内容 常见于链接 锚点                               |

## 5.3 location对象的属性

| location对象属性  | 返回值                               |
| ----------------- | ------------------------------------ |
| location.href     | 获取或者设置 整个URL                 |
| location.host     | 返回主机(域名)  www.itheima.com      |
| location.port     | 返回端口号 如果未写返回 空字符串     |
| location.pathname | 返回路径                             |
| location.search   | 返回参数                             |
| location.hash     | 返回片段 #后面的内容 常见于链接 锚点 |

**重点记住：href 和 search**

## 案例1：5秒钟之后自动跳转页面

1. 利用定时器做倒计时效果
2. 时间到了，就跳转页面，使用location.href

```html
<body>

    <button>点击</button>
    <div></div>
    <script>
        var btn = document.querySelector('button');
        btn.addEventListener('click', function () {
            location.href = 'http://www.itcast.cn';
        })

        var div = document.querySelector('div');
        var timer = 5;
        callback(); // 先调用一次函数 防止刷新页面会有空白问题
        function callback() {
            if (timer == 0) {
                location.href = 'http://www.itcast.cn';
            } else {
                div.innerHTML = '将在' + timer + '秒后跳转到首页';
                timer--;
            }

        }
        setInterval(callback, 1000);
    </script>
</body>
```

## 案例2：获取URL参数数据

主要练习数据在不同页面中的传递

1. 第一个登录界面，里面有提交表单，action提交到index.html页面
2. 第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果
3. 第二个页面之所以可以使用第一个页面的数据，是利用了URL里面的location.search参数
4. 在第二个页面中，需要把这个参数提取。
5. 第一步去掉？利用substr
6. 第二步利用=号分割 键 和 值 split(' = ')

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>login</title>
</head>

<body>
    <form action="index.html" method="get">
        用户名: <input type="text" name="username">
        <input type="submit" value="登录">
    </form>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index</title>
    <style>
        div {
            margin: 100px 20px;
            font-size: 18px;
        }
    </style>
</head>

<body>
    <div></div>
    <script>
        console.log(location.search); // ?username=red
        // 1.先去掉？ substr('起始的位置', 截取几个字符); 第二个参数不写 就是截取完
        var params = location.search.substr(1); // username=red
        console.log(params);
        // 2.利用=把字符串分割为数组 split('=');
        var arr = params.split('=');
        console.log(arr);
        var div = document.querySelector('div');
        // 3.把数据写入div中
        div.innerHTML = arr[1] + '欢迎您';


    </script>
</body>

</html>
```

## 5.4 location对象的方法

| location对象方法   | 返回值                                                       |
| ------------------ | ------------------------------------------------------------ |
| location.assign()  | 跟href一样，可以跳转页面(也称为重定向页面)                   |
| location.replace() | 替换当前页面，因为不记录历史，所以不能后退页面               |
| location.reload()  | 重新加载页面，相当于刷新按钮或者 f5 如果参数为true 强制刷新 crtl+f5 |

```html
<body>
    <button>按钮</button>
    <script>
    	var btn = document.querySelector('button');
        btn.addEventListener = ('click', function() {
            // 记录浏览历史，所以可以实现后退功能
            // location.assign(); 
            // 不记录浏览历史，所以不可以实现后退功能           
            // location.replace();
            location.reload(); // 相当于刷新页面 f5
            location.reload(true); // 相当于强制刷新ctrl+f5 强制刷新
        })
    </script>
</body>
```

# 6.navigator 对象

navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值。

下面前端代码可以判断用户那个终端打开页面，实现跳转

```javascript
if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    window.location.href = "";			// 手机
} else {
    window.location.href = "";			// 电脑
}
```

# 7.history 对象

window对象给我们提供了一个history 对象，与浏览器历史记录进行交互，该对象包含用户(在浏览器窗口中)访问过的URL。

| history对象方法 | 作用                                                       |
| --------------- | ---------------------------------------------------------- |
| back()          | 可以后退功能                                               |
| forward()       | 前进功能                                                   |
| go(参数)        | 前进后退功能 参数如果是1 前进一个页面 如果是-1 后退1个页面 |

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>首页</title>
</head>

<body>
    <a href="./index.html">点击我进入列表页</a>
    <button>前进</button>
    <script>
        var btn = document.querySelector('button');
        btn.addEventListener('click', function () {
            // history.forward();
            history.go(1);
        })
    </script>
</body>

</html>
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>列表页</title>
</head>

<body>
    <a href="./login.html">点击我进入首页</a>
    <button>后退</button>
    <script>
        var btn = document.querySelector('button');
        btn.addEventListener('click', function () {
            // history.back();
            history.go(-1);
        })
    </script>
</body>

</html>
```

history对象一般在实际开发中比较少用，但是会有一些OA办公系统中见到。

![image-20220210160803354](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220210160803354.png)

# 一、pc端网页特效

## 1.元素偏移量 offset系列

### 1.1 offset概述

offset翻译过来就是偏移量，我们使用offset系列相关属性可以**动态的**得到该元素的位置(偏移)、大小等。

- 获得元素距离带有定位父元素的位置
- 获得元素自身的大小(宽度和高度)
- 注意：返回的数值都不带单位

offset系列常用属性：

| offset系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetParent | 返回作为该元素带有定位的父级元素 如果父级都没有定位则返回body |
| element.offsetTop    | 返回元素相对带有定位父元素上方的偏移 则返回距离body的偏移    |
| element.offsetLeft   | 返回元素相对带有定位父元素左边框的偏移 则返回距离body的偏移  |
| element.offsetWidth  | 返回自身包括padding、边框、内容区的宽度。返回数值不带单位    |
| element.offsetHeight | 返回自身包括padding、边框、内容区的高度，返回数值不带单位    |

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .father {
            position: relative;
            width: 200px;
            height: 200px;
            background-color: hotpink;
        }

        .son {
            width: 100px;
            height: 100px;
            background-color: skyblue;
        }

        .w {
            width: 200px;
            height: 200px;
            background-color: purple;
            padding: 10px;
            margin: 100px 30px;
        }
    </style>
</head>

<body>
    <div class="father">
        <div class="son"></div>
    </div>
    <div class="w"></div>
    <script>
        var div = document.querySelector('.father');
        var son = document.querySelector('.son');
        var w = document.querySelector('.w');
        // 1.可以得到元素的偏移 位置 返回的不带单位的数值        
        console.log(div.offsetTop); // 0 因为清除了内外边距
        console.log(div.offsetLeft); // 0 因为清除了内外边距
        // 它以带有定位的父元素为准 如果没有父元素或者父元素没有带定位 则以body为准
        console.log(son.offsetParent); // <div class="father"></div>
        console.log(div.offsetParent); // <body></body>
        // 2.可以得到元素的大小 宽度和高度 是包含padding + border + width
        console.log(w.offsetHeight); // 220
        console.log(w.offsetWidth); // 220
        // 3.返回带有定位的父元素 否则返回body
        console.log(son.offsetParent); // <div class="father"></div> 返回带有定位的父元素 否则返回body
        console.log(son.parentNode); // <div class="father"></div> 返回父元素 是最近一级的父亲 亲爸爸 不管父元素有没有定位
    </script>
</body>

</html>
```

### 1.2 offset 与 style 区别

**offset**

- offset 可以得到任意样式表中的样式值
- offset 系列获得的数值是没有单位的
- offsetWidth 包含了padding+border+width
- offsetWidth 等属性是只读属性，只能获取不能赋值
- **所以，我们想要获取元素大小位置，用offset更合适**

------

**style**

- style 只能得到行内样式表中的样式值
- style.width获得的是带有单位的字符串
- style.width 获得不包含padding和border的值
- style.width 是可读写属性，可以获取也可以赋值
- **所以，我们想要给元素更改值，则需要style改变。**

### 案列1：获取鼠标在盒子内的坐标

1. 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。
2. 首先得到鼠标在页面中的坐标(e.pageX, e.pageY)
3. 其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)
4. 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标
5. 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件mousemove

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        div {
            width: 200px;
            height: 200px;
            background-color: hotpink;
            margin: 100px 50px;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <div></div>
    <script>
        var div = document.querySelector('div');
        div.addEventListener('mousemove', function (e) {
            console.log(e.pageX); // 鼠标到页面文档的x轴距离
            console.log(this.offsetLeft); // div与文档的左边距
            console.log(e.pageY); // 鼠标到页面文档的y轴距离
            console.log(this.offsetTop); // div与文档的上边距
            var x = e.pageX - this.offsetLeft;
            var y = e.pageY - this.offsetTop;
            div.innerHTML = 'x的坐标是' + x + ' y的坐标是' + y;

        })
    </script>
</body>

</html>
```

### 案例2：模态框拖拽

弹出框，我们也称为模态框。

1. 点击弹出层，会弹出模态框，并且显示灰色半透明的遮挡层。

2. 点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层
3. 鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。
4. 鼠标松开，可以停止拖动模态框移动。

(1).点击弹出层，模态框和遮挡层就会显示出来display：block；

(2).点击关闭按钮，模态框和遮挡层就会隐藏起来display：none；

(3).在页面中拖拽的原理：鼠标按下并且移动，之后松开鼠标

(4).触发事件是鼠标按钮mousedown，鼠标移动mousemove 鼠标松开mouseup

(5).拖拽过程：鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了。

(6).鼠标按下触发的事件源是上面一行，就是id为title。

(7).鼠标的坐标减去鼠标在盒子内的坐标，才是模态框真正的位置。

**(8).鼠标按下**，我们要得到鼠标在盒子的坐标。

**(9).鼠标移动，**就让模态框的坐标 设置为：鼠标坐标减去盒子坐标即可，注意移动事件写到按下事件里面

**(10). 鼠标松开**，就停止拖拽，就是可以让鼠标移动事件解除

```html
<style>
        * {
            padding: 0;
            margin: 0;
        }

        a {
            text-decoration: none;
        }

        .login-header {
            position: fixed;
            left: 50%;
            transform: translate(-50%);
            z-index: 2;

        }

        .login-header a {
            font-weight: 500;
            color: #000;
            font-size: 26px;
        }

        .login {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            width: 450px;
            height: 250px;
            background-color: #FCFFFC;
        }

        .login-title {
            position: relative;
            padding: 20px 0;
            text-align: center;
            font-size: 18px;
            font-weight: 400;
            cursor: move;
        }

        .login-title .close-login {
            display: inline-block;
            width: 30px;
            height: 30px;
            position: absolute;
            top: -13px;
            right: -11px;
            font-size: 12px;
            color: #000;
            text-align: center;
            line-height: 30px;
            border-radius: 50%;
            background-color: #fff;
        }

        /* .login-input-content {
            height: 200px;
            background-color: pink;
        } */

        .login-text {
            padding: 10px 0;
        }

        .login-text label {
            padding-left: 32px;
        }

        .login-text input {
            outline: none;
            height: 25px;
            width: 300px;
            border: 1px solid #999;
        }

        .login-password {
            padding: 10px 0;
        }

        .login-password label {
            padding-left: 16px;
        }

        .login-password input {
            outline: none;
            height: 25px;
            width: 300px;
            border: 1px solid #999;
        }

        .login-button {
            width: 220px;
            height: 30px;
            background-color: #fff;
            text-align: center;
            line-height: 30px;
            margin-top: 10px;
            margin-left: 126px;
            border: 1px solid #999;
        }

        .login-button a {
            text-decoration: none;
            color: #000;
        }

        .login-bg {
            display: none;
            position: fixed;
            z-index: 1;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, .3);
        }
    </style>
</head>

<body>
    <div class="login-header"><a id="link" href="javascript:;">点击, 弹出登录框</a></div>
    <div id="login" class="login">
        <div id="title" class="login-title">登录会员
            <span><a href="javascript:void(0);" class="close-login">关闭</a></span>
        </div>
        <div class="login-input-content">
            <div class="login-text">
                <label for="username">用户名: </label>
                <input type="text" placeholder="请输入用户名" name="info[username]" id="username" class="username">
            </div>
            <div class="login-password">
                <label for="password">登录密码: </label>
                <input type="password" placeholder="请输入登录密码" name="info[password]" id="password" class="password">
            </div>
        </div>
        <div id="loginBtn" class="login-button"><a href="javascript:void(0);" id="login-button-submint">登录会员</a></div>
    </div>
    <!-- 遮挡层 -->
    <div id="bg" class="login-bg"></div>
    <script>
        var link = document.querySelector('#link');
        var login = document.querySelector('.login');
        var mask = document.querySelector('.login-bg');
        var closebtn = document.querySelector('.close-login');
        var title = document.querySelector('#title');
        // 2.点击弹出层这个链接 link 让mask和login显示出来
        link.addEventListener('click', function () {
            login.style.display = 'block';
            mask.style.display = 'block';
        })
        // 3.点击关闭按钮就隐藏 mask和login
        closebtn.addEventListener('click', function () {
            login.style.display = 'none';
            mask.style.display = 'none';
        })
        // 4.开始拖拽
        // (1) 当我们鼠标按下，就获得鼠标在盒子内的坐标
        title.addEventListener('mousedown', function (e) {
            var x = e.pageX - login.offsetLeft;
            var y = e.pageY - login.offsetTop;
            // (2) 鼠标移动的时候， 把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值
            document.addEventListener('mousemove', move)
            function move(e) {
                login.style.left = e.pageX - x + 'px'; // 记得带单位
                login.style.top = e.pageY - y + 'px';
            }
            // (3) 鼠标弹起，就让鼠标移动事件移除
            document.addEventListener('mouseup', function () {
                document.removeEventListener('mousemove', move)
            })
        })
    </script>
</body>
```

### 案列3：仿京东放大镜案列

1. 整个案列可以分为三个功能模块

2. 鼠标经过小图片盒子，黄色的遮挡层和大图片盒子显示，离开隐藏2个盒子功能

   (1).就是显示与隐藏

3. 黄色的遮挡层跟随鼠标功能

   (2).把鼠标坐标给遮挡层不合适，因为遮挡层坐标以父盒子为准。

   (3).首先是获得鼠标在盒子的坐标

   (4).之后把数值给遮挡层作为left和top值

   (5).此时用到鼠标移动事件，但是还是在小图片盒子内移动。

   (6).发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。

   (7).遮挡层不能超出小图片盒子范围。

   (8).如果小于零，就把坐标设置为0.

   (9).如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离

   (10).遮挡层的最大移动距离，小图片盒子宽度 减去 遮挡层盒子宽度

4. 移动黄色遮挡层，大图片跟随移动功能

   (11).求大图片的移动距离公式 因为小图片和大图片的像素不一样 按照比列移动

   ![image-20220212151613184](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220212151613184.png)

![image-20220212151720330](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220212151720330.png)

```html
 <script src="./js/仿京东放大镜.js"></script> // 引入外部js 
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        a {
            text-decoration: none;
        }

        .w {
            width: 1210px;
            margin: 0 auto;
        }

        .con {
            display: flex;
            width: 1210px;
            height: 800px;
        }

        .preview_img {
            position: relative;
            width: 450px;
            height: 450px;
            border: 1px solid #999;
        }


        .mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 300px;
            height: 300px;
            background-color: #FFEFA7;
            opacity: .7;
            cursor: move;
            display: none;
        }

        .layer-img {
            width: 750px;
            height: 800px;
            border: 1px solid #999;
        }

        .big_img {
            display: none;
            position: absolute;
            top: 0;
            left: 616px;
            width: 500px;
            height: 500px;
            border: 1px solid #999;
            overflow: hidden;
        }

        .bigImg {
            position: absolute;
            top: 0;
            left: 0;
        }

        .layer-h3 {
            font-size: 16px;
            padding-top: 10px;
            padding-left: 10px;
            margin-bottom: 5px;
        }

        .item-hide {
            font-size: 12px;
            color: #e4393c;
            margin-bottom: 5px;
            padding-left: 10px;
        }

        .summary-price-wrap {
            height: 114px;
            padding-top: 10px;
            margin-left: 10px;
            background-color: #f3f3f3;
            overflow: hidden;
        }

        .summary-price {
            display: flex;
            justify-content: space-between;
            height: 35px;

        }

        .J-summary-price {
            height: 22px;
            line-height: 22px;
        }

        .dt {
            height: 22px;
            font-size: 12px;
            color: #999;
            letter-spacing: 2px;
            padding-left: 10px;
        }

        .price {
            height: 22px;
            font-size: 22px;
            color: #e4393c;
        }

        .notice {
            height: 22px;
            font-size: 12px;
        }

        .summary-info {
            height: 34px;
            padding-right: 10px;
        }

        .comment {
            font-size: 12px;
            color: #999;
        }

        .summary-info a {
            font-size: 14px;
        }

        .item {
            height: 32px;
            display: flex;
        }

        .dd {
            height: 18px;
            line-height: 18px;
            margin-left: 10px;
        }

        .quan-item {
            font-size: 12px;
            color: #df3033;
            border: 1px solid #df3033;
            padding: 0 10px;
            background-color: rgba(223, 48, 51, .1);
        }

        .summary-top {
            display: flex;
            justify-content: space-between;
            margin-top: 2px;
            height: 40px;
        }

        .summary-top .dt {
            width: 58px;
            height: 22px;
            line-height: 22px;
            letter-spacing: 16px;
        }

        .p-promotions {
            display: flex;
            width: 692px;
        }

        .prom-gift-label {
            display: inline;
            width: 37px;
            height: 30px;
        }

        .hl_red_bg {
            display: inline-block;
            font-size: 12px;
            color: #df3033;
            font-style: normal;
            border: 1px solid #df3033;
            padding: 2px 3px 2px 3px;


        }

        .prom-gift-list {
            width: 480px;
            height: 30px;
            display: flex;
            /* background-color: pink; */
            margin-left: 10px;
        }

        .prom-gift-item {
            width: 50px;
            height: 30px;
            margin-left: 5px;
        }

        .prom-gift-item a {
            display: inline-block;
            width: 25px;
            height: 25px;
            vertical-align: middle;
        }

        .gift-img {
            width: 25px;
            height: 25px;
        }

        .prom-gift-item em {
            font-size: 12px;
            color: #df3033;
            font-style: normal;
        }

        .gift-limit {
            height: 30px;
            line-height: 30px;
            font-size: 12px;
            color: #999;
        }
    </style>
</head>

<body>
    <div class="con w">
        <div class="preview_img">
            <img src="./images/pic.jpg">
            <div class="mask">
            </div>
        </div>
        <div class="layer-img">
            <div class="big_img">
                <img src="./images/big.jpg" class="bigImg">
            </div>
            <h3 class="layer-h3">Apple iPhone 13 (A2634) 256GB 午夜色 支持移动联通电信5G 双卡双待手机
            </h3>
            <p class="item-hide">解锁超能力！超先进双摄系统，超强耐用性，超劲续航大提升！选购[快充套装]加99元得20W快充头！更多惊喜！<a href="javascript:;">查看></a></p>
            <div class="summary-price-wrap">
                <div class="summary-price">
                    <div class="J-summary-price">
                        <span class="dt">京东价</span>
                        <span class="price">¥&thinsp;6799.00</span>
                        <a href="javascript:;" class="notice">&nbsp;降价通知</a>
                    </div>
                    <div class="summary-info">
                        <p class="comment">累计评价</p>
                        <a href="javascript:;">200万+</a>
                    </div>
                </div>
                <div class="item">
                    <span class="dt">优惠券</span>
                    <div class="dd">
                        <a href="javascript:;">
                            <span class="quan-item">满3880减400</span>
                        </a>
                    </div>
                </div>
                <div class="summary-top">
                    <span class="dt">促销</span>
                    <div class="p-promotions">
                        <span class="prom-gift-label">
                            <em class="hl_red_bg">赠品</em>
                        </span>
                        <div class="prom-gift-list">
                            <div class="prom-gift-item">
                                <a href="javascript:;" title="【免费体验】Apple产品“上手无忧”服务（赠完即止）">
                                    <img src="./images/gift-img.jpg" class="gift-img">
                                </a>
                                <em>x 1</em>
                            </div>
                            <div class="prom-gift-item">
                                <a target="_blank" href="javascript:;" title="【免费体验】Apple产品“上手无忧”服务（赠完即止）">
                                    <img src="./images/gift-img1.jpg" class="gift-img">
                                </a>
                                <em>x 1</em>
                            </div>
                            <div class="prom-gift-item">
                                <a href="javascript:;" title="【免费体验】Apple产品“上手无忧”服务（赠完即止）">
                                    <img src="./images/gift-img2.jpg" class="gift-img">
                                </a>
                                <em>x 1</em>
                            </div>
                            <span class="gift-limit">（赠完即止）</span>
                        </div>

                    </div>
                </div>
            </div>
        </div>

    </div>
</body>

</html>
```

```javascript
// js部分
window.addEventListener('load', function () {
    var preview_img = document.querySelector('.preview_img');
    var mask = document.querySelector('.mask');
    var big_img = document.querySelector('.big_img');
    // 1.鼠标经过preview_img 遮盖层mask 和大图片就显示出来 鼠标离开就隐藏
    preview_img.addEventListener('mouseover', function () {
        mask.style.display = 'block';
        big_img.style.display = 'block';
    })
    preview_img.addEventListener('mouseout', function () {
        mask.style.display = 'none';
        big_img.style.display = 'none';
    })
    // 2.鼠标移动的时候，让黄色的盒子跟着鼠标来走
    preview_img.addEventListener('mousemove', function (e) {
        // (1).先计算出鼠标在盒子内的坐标
        var x = e.pageX - this.offsetLeft;
        var y = e.pageY - this.offsetTop;
        // (2) 减去盒子高度 300的一半 是150 就是我们mask 的最终 left和top值啦
        // (3) 我们mask 移动的距离
        var maskX = x - mask.offsetWidth / 2;
        var maskY = y - mask.offsetHeight / 2;
        // (4) 如果x 坐标小于了0 就让他停在0 的位置
        // 遮挡层最大移动距离
        var maskMax = preview_img.offsetWidth - mask.offsetWidth;
        if (maskX <= 0) {
            maskX = 0;
        } else if (maskX >= maskMax) {
            maskX = maskMax;
        }
        if (maskY <= 0) {
            maskY = 0;
        } else if (maskY >= preview_img.offsetHeight - mask.offsetHeight) {  // 这里也可以等于maskMAX 因为遮挡层是一个正方形 宽和高相等
            maskY = preview_img.offsetHeight - mask.offsetHeight;
        }
        mask.style.left = maskX + 'px';
        mask.style.top = maskY + 'px';
        // 3.大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离
        // 大图
        var bigImg = document.querySelector('.bigImg');
        // 大图片最大移动距离
        var bigImgMax = bigImg.offsetWidth - big_img.offsetWidth; // 因为是正方形 只算宽就行 因为宽高相等
        // 大图片的移动距离 x y
        var bigX = maskX * bigImgMax / maskMax;
        var bigY = maskY * bigImgMax / maskMax;
        bigImg.style.left = -bigX + 'px';
        bigImg.style.top = -bigY + 'px';
    })
})

```

## 2.元素可视区clicent系列

client翻译过来就是客户端，我们使用client系列的相关属性来获取元素可视区的相关信息，通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientLeft   | 返回元素左边框的大小                                         |
| element.clientWidth  | 返回自身包括padding，内容区的宽度，不含边框，返回数值不带单位 |
| element.clientHeight | 返回自身包括padding，内容区的高度，不含边框，返回数值不带单位 |

![image-20220216113104051](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220216113104051.png)

```html
<head>
    <style>
        div {
            width: 200px;
            height: 200px;
            padding: 10px;
            background-color: pink;
            boder: 10px solid red;
        }
    </style>
</head>
<body>
    <div></div>
    <script>
    	// client 宽度和我们offsetWidth 最大的区别就是 不包含边框
        var div = document.querySelector('div');
        console,log(div.clientWidth); // 220px
    </script>
</body>
```

### 1.淘宝flexible.js源码分析

#### (1) 立即执行函数 (function() {})()  或者  (function() {}())

主要作用：创建一个独立的作用域，避免了命名和冲突问题。

```javascript
// 1.立即执行函数： 不需要电影，立马能够自己执行的函数
function fn() {
    console.log(1);
}
fn();
// 2.写法 也可以传递参数进来
// (function() {})()  或者  (function(){}());
(function() {
    console.log(3);
})(); // 用分号结尾 表示两个独立的立即执行函数 有多个立即执行函数 必须用分号隔开

(function(a,b) { // 匿名函数
    console.log(a + b);
    var num = 10;
} (2,3)) // 第二个小括号可以看做是调用函数

(function sum(a,b) { // 也可以使用函数名
    console.log(a + b);
    var num = 10; // 局部变量
} (2,3))
// 3. 立即执行函数最大作用就是 独立创建了一个作用域，里面所有的变量都是局部变量，不会有命名冲突的情况
```

#### (2) 像素比和pageshow事件

像素比 ：window.devicePixelRatio pc端的像素比是1 其他移动端不一样

pageshow事件与load事件

下面三种情况都会刷新页面都会触发load事件。

1. a标签的超链接
2. F5或者刷新按钮(强制刷新 ctrl+F5)
3. 前进后退按钮

但是 火狐中，有个特点，有个"往返缓存"，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态：实际上是将整个页面保存再来内存里。

所以此时后退按钮不能刷新页面。

此时可以使用pageshow事件来触发。这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件，**注意这个事件给window添加。**

```javascript
(function flexible(window, document) {
    // 获取的html的根元素
    var docE1 = document.documentElement
    // dpr 物理像素比 pc端像素比是1
    var dpr = window.devicePixelRatio || 1
    
    // adjust body font size 设置我们body的字体大小
    function setBodyFontSize() {
        // 如果页面中的body 这个元素 就设置body的字体大小
        if (document.body) {
            document.body.style.fontSize = (12 * dpr) + 'px';
        } else {
            // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body
            document.addEventListener(DOMContentLoaded, setBodyFontSize)
        }
    }
    setBodyFontSize();
    
    // set 1rem = viemWidth / 10  设置我们html 元素的文字大小
    function setRemUnit() {
        var rem = docE1.clientWidth / 10
        docE1.style.fontSize = rem + 'px'
    }
    setRemUnit()
    
    // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem的大小
    window.addEventListener('resize', setRemUnit)
    // pageshow 是我们重新加载页面触发的事件
    window.addEventListener('pageshow', function(e) {
        // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem的大小
        if (e.persisted) {
            setRemUnit()
        }
    })
    // detect 0.5px supports 有些移动端的浏览器不支持0.5像素的写法
    if (dpr >= 2) {
        var fakeBody = document.createElement('body')
        var testElement = document.createElement('div')
        testElement.style.border = '.5px solid transparent'
        fakeBody.spendChild(testElement)
        docE1.appendChild(fakeBody)
        if (testElement.offsetHeight === 1) {
            docE1.classList.add('hairlines')
        }
        docE1.removeChild(fakeBody)
    }
}(window,document))
```

## 3.元素滚动 scroll系列

### 3.1 元素scroll系列属性

scroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小，滚动距离等。

**注意：**元素被卷去的头部是**element.scrollTop**，如果是页面被卷去的头部则是**window.pageYOffset**

| scroll系列属性       | 作用                                           |
| -------------------- | ---------------------------------------------- |
| element.scrollTop    | 返回被卷去的上侧距离，返回数值不带单位         |
| element.scrollLeft   | 返回被卷去的左侧距离，返回数值不带单位         |
| element.scrollWidth  | 返回自身实际的宽度，不含边框，返回数值不带单位 |
| element.scrollHeight | 返回自身实际的高度，不含边框，返回数值不带单位 |

![image-20220216145309701](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220216145309701.png)

### 3.2 页面被卷去的头部

如果浏览器的高(或宽)度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部，滚动条在滚动时会触发onscroll事件。

```html
<head>
<style>
        div {
            width: 200px;
            height: 200px;
            background-color: pink;
            border: 10px solid red;
            padding: 10px;
            overflow: auto;
        }
    </style>
</head>

<body>
    <div>我是内容
        我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容
    </div>
    <script>
        // scrooll系列
        var div = document.querySelector('div');
        console.log(div.scrollHeight); // 220
        // scroll滚动事件当我们滚动条发生变化会触发的事件
        div.addEventListener('scroll', function () {
            console.log(div.scrollTop);
        })
    </script>
</body>
```

### 案列1：仿淘宝固定右侧侧边栏

1. 原先侧边栏是绝对定位
2. 当页面滚动到一定位置，侧边栏改为固定定位
3. 页面继续滚动，会让返回顶部显示出来

案列分析：

1. 需要用到页面滚动事件scroll 因为是页面滚动所以事件源是document
2. 滚动到某个位置，就是判断页面被卷去的上部值
3. **页面被卷去的头部：可以通过window.pageYOffset获得 如果是被卷去的左侧 window.pageXOffset**
4. 注意：元素被卷去的头部是element.scrollTop，如果是页面被卷去的头部则是window.pageYOffset

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .w {
            width: 1300px;
            margin: 0 auto;
        }

        .slider_bar {
            position: absolute;
            right: 61px;
            top: 410px;
            width: 50px;
            height: 100px;
            background-color: yellow;

        }

        .goBack {
            display: none;
            position: absolute;
            bottom: 0;
            font-size: 12px;

        }

        .header {
            height: 200px;
            background-color: hotpink;

        }

        .banner {
            height: 300px;
            background-color: skyblue;
        }

        .main {
            height: 800px;
            background-color: pink;
        }

        .banner,
        .main {
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="slider_bar">
        <span class="goBack">返回顶部</span>
    </div>
    <div class="header w">头部区域</div>
    <div class="banner w">banner区域</div>
    <div class="main w">主体部分</div>
    <script>
        // 1.获取元素
        var slider_bar = document.querySelector('.slider_bar');
        var banner = document.querySelector('.banner');
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        // banner.offsetTop 就是被卷去的头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop;
        // slider_bar.offsetTop 就是侧边栏距离页面顶部的距离
        var sliderTop = slider_bar.offsetTop;
        // main.offsetTop 就是main主体部分距离页面顶部的距离
        var mainTop = main.offsetTop;
        // 2.页面滚动事件 scroll
        document.addEventListener('scroll', function () {
            // console.log(11);
            // window.pageYOffset 页面被卷去的头部
            // console.log(window.pageYOffset); 这个可以侧出页面被卷去头部的值
            // 3.当我们页面被卷去的头部大于等于 216的时候 侧边栏就改为固定定位 最好不要写特定的值 所以用banner.offsetTop
            if (window.pageYOffset >= bannerTop) {
                slider_bar.style.position = 'fixed';
                slider_bar.style.top = sliderTop - bannerTop + 'px';


            } else {
                slider_bar.style.position = 'absolute';
                slider_bar.style.top = sliderTop + 'px';

            }
            // 4.当我们页面滚动到main盒子时，侧边栏里面的内容就显示出来
            if (window.pageYOffset >= mainTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';

            }
        }) 
    </script>
</body>

</html>
```

### 3.3  页面被卷去的头部兼容性解决方案

需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：

1. 声明了DTD(<!DOCTYPE html>) ，使用document.documentElement.scrollTop
2. 未声明DTD，使用document.body.scrollTop
3. 新方法window.pageYOffset 和 window.pageXOffset，IE9开始支持

```javascript
function getScroll() {
    return {
        left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
        top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    }
}
// 使用的时候
getScroll().left
```

### 3.4 三大系列总结

| 三大系列大小对比    | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| element.offsetWidth | 返回自身包括padding、边框、内容区的宽度，返回数值不带单位    |
| element.clientWidth | 返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位 |
| element.scrollWidth | 返回自身实际的宽度，不含边框，返回数值不带单位               |

![image-20220216215053156](C:\Users\刘星敏\AppData\Roaming\Typora\typora-user-images\image-20220216215053156.png)

### 三大系列主要用法：

1. offset系列经常用于获得元素位置 **offsetLeft，offsetTop**
2. client经常用于获取元素大小 **clientWidth，clientHeight**
3. scroll经常用于获取滚动距离 **scrollTop，scrollLeft**
4. **注意页面滚动的距离通过**window.pageYOffset 获得

## mouseenter 和 mouseover的区别

mouseenter鼠标事件

- 当鼠标移动到元素上时就会触发mouseenter事件
- 类似mouseover，它们两者之间的差别是
- mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter只会经过自身盒子触发
- 之所以这样，就是因为mouseenter不会冒泡
- 跟mouseenter搭配鼠标离开mouseleave同样不会冒泡

## 4.动画函数封装

### 4.1 动画实现原理

核心原理：通过定时器setInterval() 不断移动盒子位置。

实现步骤：

1. 获得盒子当前位置
2. 让盒子在当前位置加上1个移动距离
3. 利用定时器不断重复这个操作
4. 加一个结束定时器的条件
5. 注意此元素需要添加定位，才能使用element.style.left

```html
<head>   
<style>
        div {
            position: absolute;
            left: 0;
            width: 60px;
            height: 60px;
            background-color: hotpink;
        }
    </style>
</head>

<body>
    <div></div>
    <script>
        var div = document.querySelector('div');
        var timer = setInterval(function () {
            if (div.offsetLeft >= 500) {
                // 停止动画 本质是停止定时器
                clearInterval(timer);
            }
            div.style.left = div.offsetLeft + 1 + 'px';
        }, 50)
    </script>
</body>
```

### 4.2 动画函数简单封装

注意函数需要传递2个参数，**动画对象**和**移动到的距离**。

```html
<html>
    
<head>
<style>
        div {
            position: absolute;
            left: 0;
            width: 60px;
            height: 60px;
            background-color: hotpink;
        }

        span {
            position: absolute;
            left: 0;
            top: 100px;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>
</head>

<body>
    <div></div>
    <span></span>
    <script>
        // 简单动画函数封装obj目标对象 target 目标位置
        function animate(obj, target) {
            var timer = setInterval(function () {
                if (obj.offsetLeft >= target) {
                    // 停止动画 本质是停止计时器
                    clearInterval(timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';
            }, 50)
        }
        var div = document.querySelector('div');
        var span = document.querySelector('span');
        // 调用函数
        animate(div, 500);
        animate(span, 300);

    </script>
</body>

</html>
```

### 4.3 动画函数给不同元素记录不同定时器

如果多个元素都使用这个动画函数，每次都要var声明定时器。我们就要给不同的元素使用不同的定时器(自己专门用自己的定时器)。

核心原理：利用js是一门动态语言，可以很方便的给当前对象添加属性。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            position: absolute;
            left: 0;
            width: 60px;
            height: 60px;
            background-color: hotpink;
        }

        span {
            position: absolute;
            left: 0;
            top: 100px;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>
</head>

<body>
    <button>点击按钮让pink盒子动</button>
    <div></div>
    <span></span>
    <script>
        // var obj = {};
        // obj.name = 'andy';
        // 简单动画函数封装obj目标对象 target 目标位置
        // 给不同的元素指定了不同的定时器
        function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function () {
                if (obj.offsetLeft >= target) {
                    // 停止动画 本质是停止计时器
                    clearInterval(obj.timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';
            }, 50)
        }
        var div = document.querySelector('div');
        var span = document.querySelector('span');
        var btn = document.querySelector('button');
        btn.addEventListener('click', function () {
            animate(span, 300);
        })
        // 调用函数
        animate(div, 500);
    </script>
</body>

</html>
```

### 4.4 缓动效果原理

缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来

思路：

1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。
2. 核心算法：(目标值 - 现在的位置) / 10(可以改变的)  作为每次移动的距离(步长)
3. 停止的条件是：让当前盒子位置等于目标位置就停止定时器
4. 注意步长值需要取整

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        span {
            position: absolute;
            left: 0;
            top: 100px;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>
</head>

<body>
    <button class="btn500">点击按钮让pink盒子移动500</button>
    <button class="btn800">点击按钮让pink盒子移动800</button>
    <div></div>
    <span></span>
    <script>
        // var obj = {};
        // obj.name = 'andy';
        // 简单动画函数封装obj目标对象 target 目标位置
        // 给不同的元素指定了不同的定时器
        function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function () {
                // 步长值写到定时器里面
                var step = Math.ceil((target - obj.offsetLeft) / 10);
                if (obj.offsetLeft == target) {
                    // 停止动画 本质是停止计时器
                    clearInterval(obj.timer);
                }
                // 把每次加1 这个步长值改为一个慢慢变小的值 步长公式：(目标值 - 现在的位置) / 10;
                obj.style.left = obj.offsetLeft + step + 'px';
            }, 50)
        }
        var span = document.querySelector('span');
        var btn500 = document.querySelector('.btn500');
        var btn800 = document.querySelector('.btn800');
        btn500.addEventListener('click', function () {
            // 调用函数
            animate(span, 500);
        })
        btn800.addEventListener('click', function () {
            // 调用函数
            animate(span, 800);
        })
        // 匀速动画: 就是 盒子是当前的位置 + 固定的值
        // 缓动动画: 就是 盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10)
    </script>
</body>

</html>
```

### 4.5 动画函数

可以让动画函数从800移动到500.

当我们点击按钮时候，判断步长是正值还是负值

1. 如果是正值，则步长往大了取整(Math.ceil)
2. 如果是负值，则步长往小了取整(Math.floor)

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        span {
            position: absolute;
            left: 0;
            top: 100px;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>
</head>

<body>
    <button class="btn500">点击按钮让pink盒子移动500</button>
    <button class="btn800">点击按钮让pink盒子移动800</button>
    <div></div>
    <span></span>
    <script>
        // var obj = {};
        // obj.name = 'andy';
        // 简单动画函数封装obj目标对象 target 目标位置
        // 给不同的元素指定了不同的定时器
        function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function () {
                // 步长值写到定时器里面
                // 把我们步长值改为整数 不要出现小数的问题
                // var step = Math.ceil((target - obj.offsetLeft) / 10); 步长如果为负数，应该往小了取整
                var step = (target - obj.offsetLeft) / 10;
                step = step > 0 ? Math.ceil(step) : Math.floor(step);
                if (obj.offsetLeft == target) {
                    // 停止动画 本质是停止计时器
                    clearInterval(obj.timer);
                }
                // 把每次加1 这个步长值改为一个慢慢变小的值 步长公式：(目标值 - 现在的位置) / 10;
                obj.style.left = obj.offsetLeft + step + 'px';
            }, 50)
        }
        var span = document.querySelector('span');
        var btn500 = document.querySelector('.btn500');
        var btn800 = document.querySelector('.btn800');
        btn500.addEventListener('click', function () {
            // 调用函数
            animate(span, 500);
        })
        btn800.addEventListener('click', function () {
            // 调用函数
            animate(span, 800);
        })
        // 匀速动画: 就是 盒子是当前的位置 + 固定的值
        // 缓动动画: 就是 盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10)
    </script>
</body>

</html>
```

### 4.6 动画函数添加回调函数

**回调函数原理**; 函数可以作为一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做**回调。**

函数是可以作为实参传递的

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        span {
            position: absolute;
            left: 0;
            top: 100px;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>
</head>

<body>
    <button class="btn500">点击按钮让pink盒子移动500</button>
    <button class="btn800">点击按钮让pink盒子移动800</button>
    <div></div>
    <span></span>
    <script>
        // var obj = {};
        // obj.name = 'andy';
        // 简单动画函数封装obj目标对象 target 目标位置
        // 给不同的元素指定了不同的定时器
        function animate(obj, target, callback) {
            // console.log(callback); 相当于执行了callback = function() {}; 调用的时候 callback
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function () {
                // 步长值写到定时器里面
                // 把我们步长值改为整数 不要出现小数的问题
                // var step = Math.ceil((target - obj.offsetLeft) / 10); 步长如果为负数，应该往小了取整
                var step = (target - obj.offsetLeft) / 10;
                step = step > 0 ? Math.ceil(step) : Math.floor(step);
                if (obj.offsetLeft == target) {
                    // 停止动画 本质是停止计时器
                    clearInterval(obj.timer);
                    // 回调函数写到定时器结束的里面
                    if (callback) {
                        // 调用函数
                        callback();
                    }
                }
                // 把每次加1 这个步长值改为一个慢慢变小的值 步长公式：(目标值 - 现在的位置) / 10;
                obj.style.left = obj.offsetLeft + step + 'px';
            }, 50)
        }
        var span = document.querySelector('span');
        var btn500 = document.querySelector('.btn500');
        var btn800 = document.querySelector('.btn800');
        btn500.addEventListener('click', function () {
            // 调用函数
            animate(span, 500, function () {
                span.style.backgroundColor = '';

            });
        })
        btn800.addEventListener('click', function () {
            // 调用函数
            animate(span, 800, function () {
                span.style.backgroundColor = 'hotpink';
            });
        })
        // 匀速动画: 就是 盒子是当前的位置 + 固定的值
        // 缓动动画: 就是 盒子当前的位置 + 变化的值(目标值 - 现在的位置) / 10)
    </script>
</body>

</html>
```

### 4.7 动画函数封装到单独JS文件里面

因为以后经常使用这个动画效果，可以单独封装到一个JS文件里面，使用的时候引用这个js文件即可。

1. 先创建一个JS文件
2. 再引入这个js文件(<script src="./animation.js"></script>)

1.先单独创建一个js文件

```javascript
function animate(obj, target, callback) {
    // console.log(callback); 相当于执行了callback = function() {}; 调用的时候 callback
    // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
    // 解决方案就是 让我们元素只有一个定时器执行
    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInterval(function () {
        // 步长值写到定时器里面
        // 把我们步长值改为整数 不要出现小数的问题
        // var step = Math.ceil((target - obj.offsetLeft) / 10); 步长如果为负数，应该往小了取整
        var step = (target - obj.offsetLeft) / 10;
        step = step > 0 ? Math.ceil(step) : Math.floor(step);

        if (obj.offsetLeft == target) {
            // 停止动画 本质是停止计时器
            clearInterval(obj.timer);
            // 回调函数写到定时器结束的里面
            if (callback) {
                // 调用函数
                callback();
            }
        }
        // 把每次加1 这个步长值改为一个慢慢变小的值 步长公式：(目标值 - 现在的位置) / 10;
        obj.style.left = obj.offsetLeft + step + 'px';
    }, 50)
}
```

2.再引入这个js文件

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        .sliderbar {
            position: relative;
            left: 1480px;
            top: 600px;
            width: 60px;
            height: 50px;
            background-color: hotpink;
            z-index: 999;
        }

        span {
            text-align: center;
            line-height: 50px;
        }

        .con {
            position: absolute;
            left: 0;
            top: 0;
            width: 200px;
            height: 50px;
            background-color: hotpink;
            color: #000;
            font-size: 20px;
            text-align: center;
            line-height: 50px;
            z-index: -1;
        }
    </style>
    <script src="./js/animation.js"></script>
</head>

<body>
    <div class="sliderbar">
        <span>→</span>
        <div class="con">问题反馈</div>
    </div>
    <script>
        var sliderbar = document.querySelector('.sliderbar');
        var con = document.querySelector('.con');
        sliderbar.addEventListener('mouseenter', function () {
            animate(con, -200);
            sliderbar.children[0].innerHTML = '←';
        })
        sliderbar.addEventListener('mouseleave', function () {
            animate(con, 0);
            sliderbar.children[0].innerHTML = '→';
        })
    </script>
</body>

</html>
```

### 案列1：轮播图

轮播图也称为焦点图，是网页中比较常见的网页特效。

功能需求：

1. 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮
2. 点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。
3. 图片播放的同时，下面小圆圈模块跟随一起变化。
4. 点击小圆圈，可以播放相应图片。
5. 鼠标不经过轮播图，轮播图也会自动播放图片。
6. 鼠标经过，轮播图模块，自动播放停止。

案列分析：

**第一步：鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮**

1. 因为js较多，我们单独新建一个js文件夹，再新建js文件，引入页面中。
2. 此时需要添加load事件
3. 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮
4. 显示隐藏display按钮

**第二步：动态生成小圆圈**

1. 核心思路：小圆圈的个数要跟图片张数一致
2. 所以首先先得到ul里面图片的张数(图片放入ul里面，所以就是li的个数)
3. 利用循环动态生成小圆圈(这个小圆圈要放入ol里面)
4. 创建节点createElement('li')
5. 插入节点ol.appendChild(li)

**第三步：小圆圈的排他思想**

1. 点击当前小圆圈，就添加current类名
2. 其余的小圆圈就移除这个current类名
3. 注意：我们在刚才生成小圆圈的同时，就可以直接绑定这个点击事件了。

**第四步：点击小圆圈滚动图片**

1. **此时用到animate动画函数,将此js文件引入(注意：如果整体的js文件写在外面的，在引入animate.js时，要把引入的animate.js写在引入整体js文件的上面，因为整体js文件依赖于animate.js)**
2. 使用动画函数的前提，该元素必须有定位
3. 注意是ul移动 不是li
4. 滚动图片的核心算法：点击某个小圆圈，就让图片滚动 小圆圈的**索引号乘以图片的宽度**作为ul移动距离
5. 此时需要知道小圆圈的索引号，我们就要在生成小圆圈的时候，给它设置一个自定义属性，点击的时候获取这个自定义属性即可。

**第五步：克隆第一张图片**

1. 克隆ul第一个li cloneNode() 加true 深克隆 复制里面的子节点 false浅克隆
2. 添加到ul最后面 appendChild

**第六步：点击右侧按钮一次，就让图片滚动一张**

1. 声明一个变量num，点击一次，让这个变量乘以图片宽度，就是ul的滚动距离。
2. 图片无缝滚动原理
3.  （记得先把克隆的ul的第一张图片先放在ul的最后面）
4. 当图片滚动到克隆的最后一张图片时，让ul快速的、不做动画的跳到最左侧：left为0
5. 同时num赋值为0，可以从新开始滚动图片了。

**第七步：点击右侧按钮，小圆圈跟随变化**

1. 最简单的做法是再声明一个变量cirde，每次点击自增1，注意，左侧按钮也需要这个变量，因此要声明全局变量。
2. 但是图片只有6张，我们小圆圈只有5个少一个，必须加一个判断条件
3. 如果circle == 4(图片长度减一，最后一张的索引号) 就从新复原为0

**第八步：点击左侧按钮，小圆圈跟随变化**

1. 复制右侧按钮的数据过来，改一些相关的数值。
2. 当图片走到了第一张图片的时候，要快速的走到最后一张，我们的ul的left值改为（-索引号*盒子宽度)。
3. 调用的动画，走的距离也是（-索引号*盒子宽度)。
4. 小圆圈也是改为circle--， circle < 0 说明第一张图片，则小圆圈要改为第5个小圆圈(4),就是ol.length - 1

**第九步：自动播放功能**

1. 添加一个定时器
2. 自动播放轮播图，实际就类似于点击了右侧按钮
3. 此时我们使用手动调用右侧按钮点击事件 right.click()

## 5.常见网页特效按钮

### 5.1 节流阀

防止轮播图按钮连续点击造成播放过快。

节流阀的目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。

核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。

开始设置一个变量 var flag = true；

if(flag) {flag = false; do something} 关闭水龙头

利用回调函数 动画执行完毕，flag = true 打开水龙头

### 5.2 **返回顶部**

案列1：滚动窗口至文档中的特定位置

window.scroll(x,y)

注意，里面的x和y不带单位，直接写数字

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .w {
            width: 1300px;
            margin: 0 auto;
        }

        .slider_bar {
            position: absolute;
            right: 61px;
            top: 410px;
            width: 50px;
            height: 100px;
            background-color: yellow;

        }

        .goBack {
            display: none;
            position: absolute;
            bottom: 0;
            font-size: 12px;
            cursor: pointer;

        }

        .header {
            height: 200px;
            background-color: hotpink;

        }

        .banner {
            height: 300px;
            background-color: skyblue;
        }

        .main {
            height: 800px;
            background-color: pink;
        }

        .banner,
        .main {
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div class="slider_bar">
        <span class="goBack">返回顶部</span>
    </div>
    <div class="header w">头部区域</div>
    <div class="banner w">banner区域</div>
    <div class="main w">主体部分</div>
    <script>
        // 1.获取元素
        var slider_bar = document.querySelector('.slider_bar');
        var banner = document.querySelector('.banner');
        var main = document.querySelector('.main');
        var goBack = document.querySelector('.goBack');
        // banner.offsetTop 就是被卷去的头部的大小 一定要写到滚动的外面
        var bannerTop = banner.offsetTop;
        // slider_bar.offsetTop 就是侧边栏距离页面顶部的距离
        var sliderTop = slider_bar.offsetTop;
        // main.offsetTop 就是main主体部分距离页面顶部的距离
        var mainTop = main.offsetTop;
        // 2.页面滚动事件 scroll
        document.addEventListener('scroll', function () {
            // console.log(11);
            // window.pageYOffset 页面被卷去的头部
            // console.log(window.pageYOffset); 这个可以侧出页面被卷去头部的值
            // 3.当我们页面被卷去的头部大于等于 216的时候 侧边栏就改为固定定位 最好不要写特定的值 所以用banner.offsetTop
            if (window.pageYOffset >= bannerTop) {
                slider_bar.style.position = 'fixed';
                slider_bar.style.top = sliderTop - bannerTop + 'px';


            } else {
                slider_bar.style.position = 'absolute';
                slider_bar.style.top = sliderTop + 'px';

            }
            // 4.当我们页面滚动到main盒子时，侧边栏里面的内容就显示出来
            if (window.pageYOffset >= mainTop) {
                goBack.style.display = 'block';
            } else {
                goBack.style.display = 'none';

            }
            // 3.返回顶部
            goBack.addEventListener('click', function () {
                // 直接写数字，不用带单位
                window.scroll(0, 0);
            })
        }) 
```

#### 案列2：要有动画的返回顶部

1. 此时可以继续使用我们封装的动画的函数
2. 只需要把所有的leftt相关的值 改为 跟页面垂直滚动距离相关就可以了
3. 页面滚动了多少，可以通过window.pageYOffset得到

### 5.3 筋头云案列

鼠标经过某个小li，筋头云跟这到当前小li位置

鼠标离开这个小li，筋头云复原为原来的位置

鼠标点击了某个小li，筋头云就会留在点击这个小li的位置

1. 利用动画函数做动画效果
2. 原先筋头云的起始位置是0
3. 鼠标经过某个小li，把当前小li的offsetLeft位置做为目标值即可
4. 鼠标离开某个小li，就把目标值设为0
5. 如果点击了某个小li，就把li当前的位置存储起来

